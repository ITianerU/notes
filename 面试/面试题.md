# JVM

## JVM虚拟机的组成

- **类加载器子系统**

  类加载器子系统用于将编译好的．Class文件加载到JVM中

- **运行时数据区**

  运行时数据区用于存储在JVM运行过程中产生的数据, 包括

  - 程序计数器
  - 方法区
  - 本地方法区
  - 虚拟机堆
  - 虚拟机栈

- **执行引擎**

  执行引擎包括

  - 即时编译器

    即时编译器用于将Java字节码文件, 编译成具体的机器码文件

  - 垃圾回收器

    垃圾回收器用于回收在运行过程中不在使用的对象

- **本地接口库**

  本地接口库用于调用操作系统的本地方法库完成具体的指令操作

![JVM组成](../图片/面试/JVM组成.png)

## Java程序的运行过程

- Java源文件被编译为字节码文件
- JVM将字节码文件编译成相应操作系统的机器码
- 机器码调用相应操作系统的本地方法库执行相应的

## JVM内存区域

- 线程私有区域
  - 程序计数器
  
    存储java线程所执行的字节码文件的指示器
  
  - 虚拟机栈
  
    描述java方法执行过程
  
  - 本地方法区
  
    用于描述native方法执行过程
  
- 线程共享区域
  - 方法区
  
    用于存储常量, 静态变量,类信息, 即时编译器编译后的机器码,运行时常量池等数据
  
  - 堆
  
    用于存储运行时创建的对象和产生的数据
  
- 直接内存

## JVM运行时内存

![JVM运行时内存](../图片/面试/JVM运行时内存.png)

- 新生代

  默认占三分之一堆的空间, JVM新创建的对象(除了大对象)会存放在新生代, 由于JVM频繁创建对象, 所以新生代会频繁触发GC进行垃圾回收, 新生代分为eden(伊甸园)区, ServivorTo(幸存者) 区,  ServivorFrom区

  - eden: 新创建的对象会保存在eden中, eden的内存不足会触发, MInorGC, 对新生代进行垃圾回收
  - ServivorTo: 保留上一次MinorGC的幸村者
  - ServivorFrom: 将上一次的幸存者, 作为这一次的MinorGC的被扫描者

  MinorGC采用复制算法

  （1）把在Eden区和ServivorFrom区中存活的对象复制到ServivorTo区。如果某对象的年龄达到老年代的标准, 则将其复制到老年代，同时把这些对象的年龄加1；如果ServivorTo区的内存空间不够，则也直接将其复制到老年代；如果对象属于大对象（大小为2KB～128KB的对象属于大对象，则也直接将其复制到老年代。

  （2）清空Eden区和ServivorFrom区中的对象。

  （3）将ServivorTo区和ServivorFrom区互换，原来的ServivorTo区成为下一次GC时的ServivorFrom区。

- 老年代

  老年代主要存放有长生命周期的对象和大对象。老年代的GC过程叫作MajorGC。在老年代，对象比较稳定，MajorGC不会被频繁触发。在进行MajorGC前，JVM会进行一次MinorGC，在MinorGC过后仍然出现老年代空间不足或无法找到足够大的连续空间分配给新创建的大对象时，会触发MajorGC进行垃圾回收，释放JVM的内存空间。

  MajorGC采用标记清除算法，该算法首先会扫描所有对象并标记存活的对象，然后回收未被标记的对象，并释放内存空间。

  因为要先扫描老年代的所有对象再回收，所以MajorGC的耗时较长。MajorGC的标记清除算法容易产生内存碎片。在老年代没有内存空间可分配时，会抛出Out Of Memory异常.

- 永久代

  永久代存放class和meta信息, 超出虚拟机内存会报异常

  Java8之后, 永久代被元空间取代,  元空间直接使用操作系统的内存, 不使用虚拟机内存

# 垃圾回收与算法

![垃圾回收](../图片/面试/垃圾回收.png)

## 确定垃圾

### 引用计数法

java中要操作对象, 必须要先获取该对象的引用, 可通过引用计数法, 判断一个对象是否可以进行回收. 

在为一个对象添加一个引用时, 引用计数+1, 删除一个引用时, 引用计数-1. 当一个对象的引用计数为0, 则表示可以回收

**注**: 引用计数容易产生循环引用问题, 循环引用指, 两个对象互相引用, 导致引用一直存在, 无法被回收 

### 可达性分析

为了解决循环引用的问题, java采用可达性分析来判断对象是否可以被回收.

具体做法先定义一些GC roots对象, 然后以这些GC roots为起点向下搜索, 如果在GC roots与对象之间没有可到达的路径, 则说明这个对象是不可达的, 不可达对象被标记两次后, 仍然不可达, 就会被回收

## 垃圾回收算法

### 标记清除算法

基础算法, 分为标记和清除两个阶段, 在标记阶段, 标记所需要回收的对象, 在清除阶段, 清除标记的对象并释放内存

**注**:   由于标记清除算法,在清理内存后, 没有对内存重新进行整理, 因此如果内存中的小对象居多, 会引起内存碎片化问题, 继而引起大对象无法获得连续可用的空间

### 复制算法

复制算法是为了解决标记清除算法内存碎片化问题而设计的, 将内存划分两块相等的区域, 区域1, 存放新生成的对象, 在区域1存满后, 对区域1中的对象进行标记, 标记存活下来的对象, 复制到区域2中, 为连续的内存, 再对区域1中的对象进行清理.

**注:**  复制法高效, 并易于实现,但浪费内存, 同时, 系统中有大量长时间存活的对象时, 这些对象将在内存区域1和2之间来回复制影响系统效率

### 标记整理算法

结合了标记清除算法和复制算法的优点, 在标记阶段, 和标记清除算法相同, 在标记完成后, 将标记存活的对象移到内存另一端,将存活的放在同一区域, 未存活的放在同一区域, 清除未存活的对象

### 分代收集算法

标记清除散发, 复制算法, 标记整理算法都无法对所有类型的对象进行垃圾回收, 因此, 针对不同的对象采用不用的算法, 该算法时分代收集算法

分代收集算法, 让内存新生代使用复制算法, 因为新生代中有大量的对象被回收, 存活下来被复制的对象较少. 在老年代使用标记整理算法

### 分区收集算法

分区收集算法, 将堆分为连续的大小不同的小区域, 每个区域都有单独进行内存使用和垃圾回收, 这样做的好处是垃圾回收更灵活, 防止一次回收整个内存堆, 造成系统停顿时间过长, 

## JVM的类加载机制

JVM的类加载分为5个阶段：

- 加载

  jvm读取class文件， 并根据class文件的描述创建java.lang.Class对象的过程

- 验证

  验证class文件符合当前虚拟机的要求， 保障虚拟机自身安全，通过后才会加载

- 准备

- 解析

- 初始化

# 基础

## **String, StringBuffer, StringBuilder**

- **可变性**

  String, StringBuffer, StringBuilder的值都存在Char数组中

  其中String被final修饰, 为常量不可编辑

- **线程安全**

  String为常量是线程安全的

  StringBuffer内部的方法加了synchronized同步锁, 是线程安全的

  StringBuilder非线程安全

- **性能**

  String为常量, 每次修改值, 都要重新更改引用, 性能最低

  StringBuffer加了同步锁, 性能其次

  StringBuilder性能最高

```java
String a = "a";
String b = "b";
String c = a + b  
// 底层 new StringBuilder().append(a).appned(b).toString();
```

## 装箱和拆箱

- **手动装箱和拆箱**

  包装类都被final修饰,  不可修改

  **装箱**   Integer a = new Integer(100);

  **拆箱**   a.intValue(); 

- **自动装箱和拆箱**

  **装箱**   Integer a = 100;  底层调用 Integer.valueOf();

  **拆箱**   int b = c;   底层调用 intValue();

- **缓存池**

  数字在 -128 < x < 127 之间会从缓存中取值

  ```java
  Integer a = 10;
  Integer b = 10;
  a == b  // true
  ```

  ```java
  Integer a = 250;
  Integer b = 250;
  a == b  // false
  ```

  数字包装类在比较时, 有运算符的情况下, 比的是值

  ```java
  Integer a = 128;
  Integer b = 128;
  Integer c = 127;
  a == b // false
  a == c + 1 // true
  ```

  字符在  0 < x < 127 之间会从缓存中取值


## Java四种引用类型

- **强引用**

  最常见, 把一个对象赋值给一个引用变量时, 就是强引用, 强引用必然是可达的, 不会被垃圾回收机制回收

- **软引用**

  通过SoftReference类实现。如果一个对象只有软引用，则在系统内存空间不足时该对象将被回收。

  常用于缓存

- **弱引用**

  弱引用通过WeakReference类实现，如果一个对象只有弱引用，则在垃圾回收过程中一定会被回收。

- **虚引用**

  虚引用通过PhantomReference类实现，虚引用和引用队列联合使用，主要用于跟踪对象的垃圾回收状态。

## 集合

### List

#### ArrayList

基于数组实现， 查询快， 增删慢， 线程不安全

#### Vector

数据结构和ArrayList相同， 不同的是Vector是线程安全的， 操作元素的方法被synchronized修饰， 读写效率低于ArrayList

#### LinkedList

基于双向链表实现， 增删快， 查询慢

### Queue

**ArrayBlockingQueue**：基于数组数据结构实现的有界阻塞队列。

**LinkedBlockingQueue**：基于链表数据结构实现的有界阻塞队列， 不指定容量就是无界队列。

**PriorityBlockingQueue**：支持优先级排序的无界阻塞队列。

**DelayQueue**：支持延迟操作的无界阻塞队列。

**SynchronousQueue**：用于线程同步的阻塞队列。

**LinkedTransferQueue**：基于链表数据结构实现的无界阻塞队列。

**LinkedBlockingDeque**：基于链表数据结构实现的双向阻塞队列。

**ps**: 阻塞队列是指， 如果队列是空， 一个线程要取元素会被阻塞， 直到另一个线程往里添加了元素； 

如果队列是满的， 一个线程往里加元素也会被阻塞， 等待另一个线程取出元素，空出位置。 