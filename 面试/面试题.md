# 基础

## **String, StringBuffer, StringBuilder**

- **可变性**

  String, StringBuffer, StringBuilder的值都存在Char数组中

  其中String被final修饰, 为常量不可编辑

- **线程安全**

  String为常量是线程安全的

  StringBuffer内部的方法加了synchronized同步锁, 是线程安全的

  StringBuilder非线程安全

- **性能**

  String为常量, 每次修改值, 都要重新更改引用, 性能最低

  StringBuffer加了同步锁, 性能其次

  StringBuilder性能最高

```java
String a = "a";
String b = "b";
String c = a + b  
// 底层 new StringBuilder().append(a).appned(b).toString();
```

## 装箱和拆箱

- **手动装箱和拆箱**

  包装类都被final修饰,  不可修改

  **装箱**   Integer a = new Integer(100);

  **拆箱**   a.intValue(); 

- **自动装箱和拆箱**

  **装箱**   Integer a = 100;  底层调用 Integer.valueOf();

  **拆箱**   int b = c;   底层调用 intValue();

- **缓存池**

  数字在 -128 < x < 127 之间会从缓存中取值

  ```java
  Integer a = 10;
  Integer b = 10;
  a == b  // true
  ```

  ```java
  Integer a = 250;
  Integer b = 250;
  a == b  // false
  ```

  数字包装类在比较时, 有运算符的情况下, 比的是值

  ```java
  Integer a = 128;
  Integer b = 128;
  Integer c = 127;
  a == b // false
  a == c + 1 // true
  ```

  字符在  0 < x < 127 之间会从缓存中取值


## Java四种引用类型

- **强引用**

  最常见, 把一个对象赋值给一个引用变量时, 就是强引用, 强引用必然是可达的, 不会被垃圾回收机制回收

- **软引用**

  通过SoftReference类实现。如果一个对象只有软引用，则在系统内存空间不足时该对象将被回收。

  常用于缓存

- **弱引用**

  弱引用通过WeakReference类实现，如果一个对象只有弱引用，则在垃圾回收过程中一定会被回收。

- **虚引用**

  虚引用通过PhantomReference类实现，虚引用和引用队列联合使用，主要用于跟踪对象的垃圾回收状态。

## 类在实例化内部执行顺序

1. 加载父类的给静态变量赋值的方法, 静态代码块,  先后的顺序由代码的上下位置决定, 

   再加载子类的给静态变量赋值的方法, 静态代码块

   **静态代码块, 给静态变量赋值的方法, 在类加载时就会触发**

2. 调用父类给非静态变量赋值的方法**(如果该方法被子类重写, 则会调用子类的方法, 因为this指向当前正在创建的对象, 也就是子类的对象)**, 非静态代码块, 先后的顺序由代码的上下位置决定, 

   接着再调用父类的构造方法

3. 调用子类给非静态变量赋值的方法, 非静态代码块,先后的顺序由代码的上下位置决定, 

   最后调用子类的构造方法

## 关键字

### Volatile

#### 请你谈谈对Volatile的理解

Volatile是java虚拟机提供的轻量级的同步机制, 有三大特性

- 保证可见性

  有三个线程同时操作主内存中的一条数据, 三个线程会各自往自己的工作内存中拷贝这条数据, 处理完之后再写回主内存, 这时候就会出现, 线程一修改完, 其他线程并不知道线程一已经修改了数据, 

  Volatile保证可见性解决了这个问题, 让线程一在修改完后, 通知给其他正在处理的线程, 重新从主内存拷贝数据, 再重新处理

  ```java
  /*
   *  验证volatile的可见性
   * */
  class MyData {
      // int num = 0;  此例子, 没有加Volatile关键字, 主线程不会受到变量已经被修改的通知
      volatile int num = 0; // 使用volatile, 主线程会受到变量已经被修改的通知, 会从主内存中再次获取数据的拷贝
      public void addTo60() {
          this.num = 60;
      }
  }
  public class VolatileDemo {
      public static void main(String[] args) {
          MyData myData = new MyData();
          new Thread(() -> {
              System.out.println(Thread.currentThread().getName() + "\t 开始修改");
              try {
                  TimeUnit.SECONDS.sleep(3);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              myData.addTo60();
              System.out.println(Thread.currentThread().getName() + "\t 修改成 " + myData.num);
          }, "aaa").start();
          // 如果没有加Volatile关键字, 由于线程aaa在自己的工作空间中修改了值, 主线程并不知道, 所以会无线循环
          while (myData.num == 0) {
  
          }
          System.out.println(Thread.currentThread().getName() + "\t 主线程结束");
      }
  }
  ```

- 不保证原子性

  原子性的意思是, 不可分割, 完整性, 即某个线程再做某个具体的业务的时候, 中间不可以被加塞或者被分割, 要么同时成功, 要么失败.

  不保证原子性是, 因为有可能出现多个线程同时处理一条数据, 再一个线程将数据写回主内存之后, 没等到通知其他线程数据已被修改, 另一个线程也立刻将数据写回了主内存, 覆盖了上一个线程的处理结果

  ```java
  /*
   *  验证volatile的不保证原子性
   * */
  class MyData {
      volatile int num = 0; 
      public void addPlusPlus() {
          this.num++;
      }
  }
  public class VolatileDemo {
      public static void main(String[] args) {
          MyData myData = new MyData();
          for (int i = 0; i < 20; i++) {
              new Thread(() -> {
                  for (int i1 = 0; i1 < 1000; i1++) {
                      myData.addPlusPlus();
                  }
              }, "thread" + i).start();
          }
  
          // Thread.activeCount()获取当前正在执行的线程数量, 默认有两个线程main线程和gc线程
          while (Thread.activeCount() > 2){
              // 将当前线程交出去不执行
              Thread.yield();
          }
          // 最终结果不等于20000
          System.out.println("最终结果: " + myData.num);
      }
  }
  ```

- 禁止指令重排

  指令重排的意思是, 在多线程环境下, 计算机在执行程序的时候,为了提高性能, 编译器和处理器常常会对指令重排 ,

  指令在重排的时候, 必须要考虑单线程下的数据的依赖性,

  ```java
  public void method(){
      int a = 0;
      int b = 1;
      a = a + 1;
      // 因为b依赖a * a, 所以在指令重排时, b = a * a不会被排到前面
      b = a * a;
  }
  // 方法A和方法B分别被两个线程调用, 内部没有依赖性, 指令重排之后结果可能就会不同
  int a,b,x,y = 0;
  public void methodA(){
  	b = 1;
  	x = a;
  }
  public void methodB(){
  	a = 2;
  	y = b;
  }
  ```

   volatile会禁止指令重排, 避免出现上方代码的问题

#### 如何解决不保证原子性的问题

- 使用synchronized修饰方法(损耗较高)
- 使用原子包装类AtomicInteger等, 这些类, 天生就自带原子性

```java
AtomicInteger num = new AtomicInteger(0);
public synchronized void addPlusPlus() {
    this.num.addAndGet(1);
}
```

#### 你在什么情况下使用过Volatile

双重校验锁,  使用Volatile的原因是, 在创建对象的时候, 要经历三个步骤

1. 分配对象内存空间
2. 初始化对象
3. 将变量指向内存空间   // 此时变量 != null

经过指令重排后, 可能会变成

1. 分配对象内存空间
2. 将变量指向内存空间    // 此时变量 != null,   这时另一个线程来取值, 发现该变量不位null, 就直接拿去使用, 就会报空指针 
3. 初始化对象              

## 集合

### List

**ArrayList**

基于数组实现， 查询快， 增删慢， 线程不安全

- **new了一个ArrayList低层创建了一个什么对象**

  创建了一个Object类型数组, 默认大小为10, 超过容量扩容现有容量的一半

- **线程不安全例子**

  **例子**

  ```java
  public class ContainerNotSafeDemo {
  
      public static void main(String[] args) {
          List<String> list = new ArrayList<>();
          // 30个线程同时操作ArrayList, 部分线程会操作不成功, 会报, 
          // java.util.ConcurrentModificationException 异常
          for (int i = 0; i < 30; i++) {
              new Thread(() -> {
                  list.add(UUID.randomUUID().toString());
                  System.out.println(list);
              }, "thread" + i).start();
          }
      }
  }
  ```

  **原因**

  **解决方案**

  - Vector(不推荐), 性能差

  - ```java
    // 集合工具类
    Collections.synchronizedList(new ArrayList<>());
    ```
    
  - ```java
    // 写时复制技术 (推荐), 适合读多写少的场景
    // 使用读写分离的思想
    // 当进行写入操作的时候, 需要将oldList复制出一份, 并且容量+1, 在newList的末尾写入, 然后再将oldList的引用指向newList
    // 这样做的好处是, 读写分离, 读操作还在读oldList, 写入在newList
    // 对比Vector, CopyOnWriteArrayList的读不是不加锁的, 写入加lock锁, Vector是所有方法都是synchronized修饰的,
    List<String> list = new CopyOnWriteArrayList<>();
    ```

**Vector**

数据结构和ArrayList相同， 不同的是Vector是线程安全的， 操作元素的方法被synchronized修饰， 读写效率低于ArrayList

**LinkedList**

基于双向链表实现， 增删快， 查询慢

### Queue

队列

**ArrayBlockingQueue**：基于数组数据结构实现的有界阻塞队列。

**LinkedBlockingQueue**：基于链表数据结构实现的有界阻塞队列， 不指定容量就是无界队列。

**PriorityBlockingQueue**：支持优先级排序的无界阻塞队列。

**DelayQueue**：支持延迟操作的无界阻塞队列。

**SynchronousQueue**：用于线程同步的阻塞队列。只能存一个元素

**LinkedTransferQueue**：基于链表数据结构实现的无界阻塞队列。当队列中无元素时, 消费线程取元素, 队列会生成一个空节点, 消费线程等待这个节点, 后面生产线程要加入队列时, 发现空节点, 就不入队, 直接填充到空节点上, 唤醒消费线程消费.相对于LinkedBlockingQueue效率更高.

**LinkedBlockingDeque**：基于链表数据结构实现的双向阻塞队列。

**ps**: 阻塞队列是指， 如果队列是空， 一个线程要取元素会被阻塞， 直到另一个线程往里添加了元素； 

如果队列是满的， 一个线程往里加元素也会被阻塞， 等待另一个线程取出元素，空出位置。 

### Set

Set存储的集合数据不会重复

**HashSet**: 无序,线程不安全

HashSet存放散列值, 按照元素的散列值来存取元素, 散列值通过元素的hashCode方法计算得到.  HashSet在存放元素会先比较元素的散列值是否相等, 如果散列值相等, 再通过equals比较, 都相等视为同一元素, 

**HashSet低层**

低层是**HashMap**, 初始值是16, 使用HashMap的key实现吗value是一个固定常量

**线程不安全解决方案**

1. ```java
   // 集合工具类
   Set<String> set = Collections.synchronizedSet(new HashSet());
   ```

2. ```java
   // 基于CopyOnWriteArrayList实现
   Set<String> set = new CopyOnWriteArraySet<>();
   ```

**TreeSet**: 有序

TreeSet基于二叉树的原理, 对新添加的对象进行排序

Integer和String等基础对象可以直接排序,  自定义的数据类型需要实现Comparable接口, 重写其中的compareTo函数才能排序

**LinkedHashSet**:  有序

LinkedHashSet在底层使用LinkedHashMap存储元素, 继承了HashSet

### Map

**线程不安全解决方案**

1. ```java
   // 集合工具类
   Map<String, String> map = Collections.synchronizedMap(new Hashtable<>());
   ```

2. ```java
   Map<String, String> map = new HashTable();
   ```

3. ```java
   // 分段锁实现
   Set<String> set = new ConcurrentHashMap<>();
   ```

**HashMap**:  数组+链表/红黑树,  线程不安全

HashMap基于键的HashCode值为唯一标识,  进行存取.  每次遍历的顺序无法保证相同, key和value允许为null

**ConcurrentHashMap:**   分段锁实现,  线程安全

ConcurrentHashMap由多个Segment组成,  每个Segment单独加锁, 默认16个, 就可以同时支持16个线程并发执行写操作

**HashTable:**  线程安全

操作与HashMap类似, 是线程安全,  但是同一时间只能有一个线程可写入,  并发性不如ConcurrentHashMap

**TreeMap**:  有序

TreeMap基于二叉树数据结构, 存储数据,   使用TreeMap时其key必须实现Comparable接口或采用自定义的比较器

**LinkedHashMap**:   有序

基于HashTable数据结构, 其内部使用链表保存元素的插入顺序

## 异常

Throwable是所有错误或异常的父类,  Throwable又可分为Error和Exception, 

Error指java程序运行错误, 出现Error的原因通常是因为系统内部错误, 或资源耗尽, 无法处理, 系统只能记录错误的成因和安全终止 

Exception指程序运行时异常,即运行中的程序发生了人们不可期望的事件, 

### 异常处理方式

#### 抛出异常

将异常抛出给调用者, 调用者根据情况处理

throws在方法上定义要抛出得异常

throw手动抛出一个异常

#### 捕获异常

try catch

## 反射机制

### 反射的步骤

1. 获取想要操作的类的Class对象, 该Class对象是反射的核心, 通过它可以调用类的任意方法

   获取Class对象的三种方法

   - 调用对象的getClass方法

     ```java
     Person person = new Person();
     Class clazz = person.getClass();
     ```

   - 调用某个类的class属性

     ```java
     Class clazz = Person.class;
     ```

   - 调用Class类中的forName静态方法,  最安全, 性能最好

     ```java
     Class clazz = Class.forName("包名.类名");
     ```

2. 调用Class对象所对应的类中定义的方法, 这是反射的使用阶段

3. 使用反射API来获取并调用类的属性和方法信息

   获取类的所有方法的信息

   ```java
   Method[] method = clazz.getDeclaredMethods();
   ```

   获取类所有成员的属性信息

   ```java
   Field[] field = clazz.getDeclaredFields();
   ```

   获取类所有构造方法的信息

   ```java
   Constructor[] constructor = clazz.getDeclaredConstructors();
   ```

### 创建对象

- 使用Class对象的newInstanse方法创建Class对象对应类的实例,  这种方法要求该Class对象对应的类有默认的空构造器

  ```java
  Class clazz = Class.forName("Person");
  Person p = clazz.newInstance();
  ```

- 先获取构造方法, 使用构造方法创建对象

  ```java
  Constructor c = clazz.getDeclaredConstructor(int.class, String,class);
  Person p = (Person)c.newInstance("老王", 20);
  ```

### 调用方法

获取对象的Method,  然后通过invoke方法调用

```java
Class clazz = Class.forName("Person");
// setName是方法名, String是该方法的参数类型, 有几个写几个
Method method = clazz.getMethod("setName", String.class);
Person p = clazz.newInstance();
method.invoke(p, "老王");
```

## 内部类

### 静态内部类

定义在类内部的静态类被称为静态内部类,  静态内部类可以访问外部类的静态变量和方法,在静态内部类中可定义静态变量, 方法, 构造函数等; 静态内部类通过 "外部类. 静态内部类"的方式调用.

### 成员内部类

定义在类内部的非静态类叫做成员内部类,  成员内部类不能定义静态方法和变量(final修饰除外)

### 局部内部类

定义在方法中的类叫做局部内部类, 当一个类只需要在某个方法中使用某个特定的类时, 可以通过局部内部类来优雅的实现

### 匿名内部类

匿名内部类指通过继承一个父类或者实现一个接口的方式, 直接定义并使用的类,. 匿名类在使用时, 直接new生成一个对象, 在对象中重写方法.

## 泛型

用于约束参数类型, 提供了编译时类型的安全检测机制

### 泛型方法

```java
public class Main {
    public static void main(String[] args) {
        Main m = new Main();
        m.doSome(10, "老王");
    }
    public < T > void doSome(T ... array){
        for(T item: array){
            if(item instanceof Integer){
                System.out.println("数字");
            }else if(item instanceof String){
                System.out.println("字符串");
            }
        }
    }
}
```

### 泛型类

在类上定义一个或多个类型参数, 该参数在类实例化时传入, 类内部会将该参数作为数据类型使用

```java
public class Main<T, Q, M> {
    private T t;
    private Q q;
    private M m;
    public void set(T t, Q q, M m){
        this.t = t;
        this.q = q;
        this.m = m;
    }
    public void print(){
        System.out.println(t);
        System.out.println(q);
        System.out.println(m);
    }
    public static void main(String[] args) {
        Main<Integer, String, Double> m = new Main();
        m.set(1, "老王", 1.2);
        m.print();
    }
}
```

### 泛型接口

用法与泛型类类似,  类在实现接口时, 指定接口的泛型

```java
public interface Api<T>{
	public T print();
}
public class ApiImpl implements Api<Integer>{
	public Integer print(){
       // todo
    }
}
```

### 类型擦除

泛型在编译阶段, 会被编译器编译时去掉

## 序列化

序列化的作用是让Java对象及其状态在多个应用之间传递, 共享, 或者将对象及其状态持久化, 在其他地方重新读取被保存的对象, 并继续进行处理

常用于RPC远程调用, 网络传输

### 序列化API使用

注意事项

- 要实现序列化, 只需要实现java.io.Serializable接口即可
- 序列化和反序列化必须保持序列化的ID一致,   一般使用private staic final long serialVersionUID定义序列化ID
- 序列化并不保存静态变量
- 在需要序列化父类变量时, 父类也需要实现Serializable接口
- 使用Transient关键字可以阻止该变量被序列化, 在被反序列化后，transient变量的值被设为对应类型的初始值，例如，int类型变量的值是0，对象类型变量的值是null。

# JVM

## JVM虚拟机的组成

- **类加载器子系统**

  类加载器子系统用于将编译好的．Class文件加载到JVM中

- **运行时数据区**

  运行时数据区用于存储在JVM运行过程中产生的数据, 包括

  - 程序计数器
  - 方法区
  - 本地方法区
  - 虚拟机堆
  - 虚拟机栈

- **执行引擎**

  执行引擎包括

  - 即时编译器

    即时编译器用于将Java字节码文件, 编译成具体的机器码文件

  - 垃圾回收器

    垃圾回收器用于回收在运行过程中不在使用的对象

- **本地接口库**

  本地接口库用于调用操作系统的本地方法库完成具体的指令操作

![JVM组成](../图片/面试/JVM组成.png)

## Java程序的运行过程

- Java源文件被编译为字节码文件
- JVM将字节码文件编译成相应操作系统的机器码
- 机器码调用相应操作系统的本地方法库执行相应的

## JVM内存区域

- 线程私有区域

  - 程序计数器

    存储java线程所执行的字节码文件的指示器

  - 虚拟机栈

    描述java方法执行过程

  - 本地方法区

    用于描述native方法执行过程

- 线程共享区域

  - 方法区

    用于存储常量, 静态变量,类信息, 即时编译器编译后的机器码,运行时常量池等数据

  - 堆

    用于存储运行时创建的对象和产生的数据

- 直接内存

## JVM运行时内存

![JVM运行时内存](../图片/面试/JVM运行时内存.png)

- 新生代

  默认占三分之一堆的空间, JVM新创建的对象(除了大对象)会存放在新生代, 由于JVM频繁创建对象, 所以新生代会频繁触发GC进行垃圾回收, 新生代分为eden(伊甸园)区, ServivorTo(幸存者) 区,  ServivorFrom区

  - eden: 新创建的对象会保存在eden中, eden的内存不足会触发, MInorGC, 对新生代进行垃圾回收
  - ServivorTo: 保留上一次MinorGC的幸村者
  - ServivorFrom: 将上一次的幸存者, 作为这一次的MinorGC的被扫描者

  MinorGC采用复制算法

  （1）把在Eden区和ServivorFrom区中存活的对象复制到ServivorTo区。如果某对象的年龄达到老年代的标准, 则将其复制到老年代，同时把这些对象的年龄加1；如果ServivorTo区的内存空间不够，则也直接将其复制到老年代；如果对象属于大对象（大小为2KB～128KB的对象属于大对象，则也直接将其复制到老年代。

  （2）清空Eden区和ServivorFrom区中的对象。

  （3）将ServivorTo区和ServivorFrom区互换，原来的ServivorTo区成为下一次GC时的ServivorFrom区。

- 老年代

  老年代主要存放有长生命周期的对象和大对象。老年代的GC过程叫作MajorGC。在老年代，对象比较稳定，MajorGC不会被频繁触发。在进行MajorGC前，JVM会进行一次MinorGC，在MinorGC过后仍然出现老年代空间不足或无法找到足够大的连续空间分配给新创建的大对象时，会触发MajorGC进行垃圾回收，释放JVM的内存空间。

  MajorGC采用标记清除算法，该算法首先会扫描所有对象并标记存活的对象，然后回收未被标记的对象，并释放内存空间。

  因为要先扫描老年代的所有对象再回收，所以MajorGC的耗时较长。MajorGC的标记清除算法容易产生内存碎片。在老年代没有内存空间可分配时，会抛出Out Of Memory异常.

- 永久代

  永久代存放class和meta信息, 超出虚拟机内存会报异常

  Java8之后, 永久代被元空间取代,  元空间直接使用操作系统的内存, 不使用虚拟机内存

## JAVA内存模型(JMM)

本身是一种抽象概念, 并不真实存在, 他描述的是一组规范或规则, 通过这组规范定义了程序中的各个变量(包括实例字段, 静态字段,和构成数组的对应的元素)的访问方式

### JMM关于同步的规定

1. 线程解锁前, 必须把共享变量的值刷新会主内存
2. 线程加锁前, 必须读取主内存的最新值到自己的工作内存
3. 加锁和解锁是同一把锁

#### 主内存

Java内存模型规定了, 所有变量都存储在主内存, 主内存是共享内存区域, 所有线程都可以访问

#### 工作内存

由于JVM运行的实体是线程, 而每个线程创建的时候, JVM都会给其创建一个工作内存(栈空间), 工作内存是每个线程的私有数据区域. 

线程对变量的操作, 必须要在工作内存中进行, 首先要将变量从主内存拷贝到自己的工作内存空间, 然后对变量进行操作. 操作完成再写回主内存

各个线程的工作内存中保存着主内存的**变量副本拷贝**, 因此不同的线程无法访问对方的工作内存, 线程之间的通信(传值)必须再在主内存来完成 

### 三大特性

- 可见性
- 原子性
- 有序性

# 垃圾回收与算法

![垃圾回收](../图片/面试/垃圾回收.png)

## 确定垃圾

### 引用计数法

java中要操作对象, 必须要先获取该对象的引用, 可通过引用计数法, 判断一个对象是否可以进行回收. 

在为一个对象添加一个引用时, 引用计数+1, 删除一个引用时, 引用计数-1. 当一个对象的引用计数为0, 则表示可以回收

**注**: 引用计数容易产生循环引用问题, 循环引用指, 两个对象互相引用, 导致引用一直存在, 无法被回收 

### 可达性分析

为了解决循环引用的问题, java采用可达性分析来判断对象是否可以被回收.

具体做法先定义一些GC roots对象, 然后以这些GC roots为起点向下搜索, 如果在GC roots与对象之间没有可到达的路径, 则说明这个对象是不可达的, 不可达对象被标记两次后, 仍然不可达, 就会被回收

## 垃圾回收算法

### 标记清除算法(老年代)

基础算法, 分为标记和清除两个阶段, 在标记阶段, 标记所需要回收的对象, 在清除阶段, 清除标记的对象并释放内存

**注**:   由于标记清除算法,在清理内存后, 没有对内存重新进行整理, 因此如果内存中的小对象居多, 会引起内存碎片化问题, 继而引起大对象无法获得连续可用的空间

### 复制算法(年轻代)

复制算法是为了解决标记清除算法内存碎片化问题而设计的, 将内存划分两块相等的区域, 区域1, 存放新生成的对象, 在区域1存满后, 对区域1中的对象进行标记, 标记存活下来的对象, 复制到区域2中, 为连续的内存, 再对区域1中的对象进行清理.

**注:**  复制法高效, 并易于实现,但浪费内存, 同时, 系统中有大量长时间存活的对象时, 这些对象将在内存区域1和2之间来回复制影响系统效率

### 标记整理算法(老年代)

结合了标记清除算法和复制算法的优点, 在标记阶段, 和标记清除算法相同, 在标记完成后, 将标记存活的对象移到内存另一端,将存活的放在同一区域, 未存活的放在同一区域, 清除未存活的对象

### 分代收集算法

标记清除散发, 复制算法, 标记整理算法都无法对所有类型的对象进行垃圾回收, 因此, 针对不同的对象采用不用的算法, 该算法时分代收集算法

分代收集算法, 让内存新生代使用复制算法, 因为新生代中有大量的对象被回收, 存活下来被复制的对象较少. 在老年代使用标记整理算法

### 分区收集算法

分区收集算法, 将堆分为连续的大小不同的小区域, 每个区域都有单独进行内存使用和垃圾回收, 这样做的好处是垃圾回收更灵活, 防止一次回收整个内存堆, 造成系统停顿时间过长, 

## JVM的类加载机制

JVM的类加载分为5个阶段：

- 加载

  jvm读取class文件， 并根据class文件的描述创建java.lang.Class对象的过程

- 验证

  验证class文件符合当前虚拟机的要求， 保障虚拟机自身安全，通过后才会加载

- 准备

- 解析

- 初始化

# 并发

## 线程的创建方式

### 继承Thread类

```java
public class Main extends Thread{
    public static void main(String[] args) {
        Main m = new Main();
        m.start();
    }
    public void run(){
        System.out.println("lalalal...");
    }
}
```

### 实现Runnable接口

```java
public class Main implements Runnable{
    public static void main(String[] args) {
        Main m = new Main();
        Thread thread = new Thread(m);
        thread.start();
    }
    public void run(){
        System.out.println("jijiji...");
    }
}
```

### 实现Callable接口

让线程带返回值

```java
class MyThread implements Callable<Integer>{
    @Override
    public Integer call() throws Exception {
        System.out.println(123);
        return 1024;
    }
}

public class CallableDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 多个线程要使用多个FutureTask
        FutureTask<Integer> futureTask = new FutureTask<>(new MyThread());
        // FutureTask<Integer> futureTask2 = new FutureTask<>(new MyThread());
        Thread t = new Thread(futureTask);
        // Thread t2 = new Thread(futureTask2);
        t.start(); 

        System.out.println(futureTask.get());
    }
}
```

### 通过ExecutorService和Callable<Class>实现有返回值的线程

当需要开启多个线程执行同一个任务, 并收集各个线程执行的返回结果, 需要用的Callable接口.

```java
public class Main implements Callable<String> {
    private String name;
    public Main(String name){
        this.name = name;
    }
    @Override
    public String call() throws Exception {
        return name;
    }
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(5);
        List<Future> list = new ArrayList<>();
        for (int i=0; i<5; i++){
            Callable c = new Main(i + "");
            // pool.submit 提交指定的任务去执行, 并且返回Future对象
            // Future表示一个可能还没有完成的异步任务结果
            Future future = pool.submit(c);
            System.out.println("submit a callable thread:" + i);
            list.add(future);
        }
        for (Future f : list){
            // get方法让我们等待Calable结束, 并获取执行的结果
            System.out.println(f.get().toString());
        }
        pool.shutdown();
    }
}
```

### 基于线程池

```java
public class Main implements Runnable {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 创建线程池
        ExecutorService pool = Executors.newFixedThreadPool(10);
        for (int i=0; i<10; i++){
            pool.execute(new Main() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName() + " is running");
                }
            });
        }
    }
    @Override
    public void run() {}
}
```

### 线程池工作原理

Java线程池主要用于管理线程组及其运行状态,以便Java虚拟机更好的利用cpu资源,

工作原理为: JVM先根据用户参数创建一定数量的可运行的线程任务, 将其放入队列中, 在线程创建后启动这些任务，如果线程数量超过了最大线程数量（用户设置的线程池大小），则超出数量的线程排队等候，在有任务执行完毕后，线程池调度器会发现有可用的线程，进而再次从队列中取出任务并执行。

线程池的主要作用是线程复用、线程资源管理、控制操作系统的最大并发数，以保证系统高效（通过线程资源复用实现）且安全（通过控制最大线程并发数实现）地运行。

#### 线程池的核心组件和核心类

- **线程池管理器**: 用于创建并管理线程池
- **工作线程**: 线程池中执行具体任务的线程
- **任务接口**: 用于定义工作线程的调度和执行策略, 只有线程实现了该接口, 线程中的任务才能够被线程池调度
- **任务队列**: 存放待处理的任务, 新的任务将会不断加入到队列中, 执行完的任务, 将会从队列中移除

#### 线程池的工作流程

线程池在刚创建的时候, 只向系统申请一个用于执行线程队列, 和管理线程池的线程资源, 在调用execute()添加任务时,线程池的工作流程如下

- 当正在运行的线程数量少于规定的核心线程数量, 线程池立即创建线程, 并执行任务
- 当正在运行的线程数量大于或者等于核心线程数量, 该任务被加入到阻塞队列中
- 当阻塞队列已满, 正在运行的线程数量小于最大线程数量, 线程池创建非核心线程, 并执行任务
- 当阻塞队列已满, 正在运行的线程数量大于等于最大线程数量, 线程池拒绝执行该任务, 抛出RejectExecutionException异常
- 在线程执行完毕, 该任务从阻塞队列中移除, 读取队列下一个任务执行
- 线程处于空闲状态超过设置的时间, 并且为非核心线程, 线程池会停止非核心线程.  线程池所有任务执行完毕后, 线程池大小会收缩到设置的核心线程数量的大小

![线程池工作流程](../图片/面试/线程池工作流程.png)

### 常用线程池

- **newCachedThreadPool**  可缓存的线程池

  在创建新线程时, 如果有可用的线程, 则重用他们(任务完成但未关闭的线程)

  该线程池可无限扩大, 适用于处理时间比较小的任务

  ```java
  ExecutorService pool = Executors.newCachedThreadPool();
  ```

- **newFixedThreadPool**  固定大小线程池

  ```java
  ExecutorService pool = Executors.newFixedThreadPool(10);
  ```

- **newScheduledThreadPool**  可做任务调度的线程池

  创建了一个可定时调度的线程池, 可设置在给定的延迟时间后执行或者定期执行某个线程任务

  ```java
  ScheduledExecutorService pool = Executors.newScheduledThreadPool(3);
  pool.schedule(new Runnable() {
      @Override
      public void run() {
          System.out.println("延迟3秒, 执行一次");
      }
  }, 3, TimeUnit.SECONDS);
  
  pool.scheduleAtFixedRate(new Runnable() {
      @Override
      public void run() {
          System.out.println("延迟1秒, 每三秒执行一次");
      }
  }, 1, 3, TimeUnit.SECONDS);
  ```

- **newSingleThreadExecutor**   单个线程的线程池

  保证永远有且只有一个可用的线程, 在该线程异常或停止时, 会创建一个新的线程执行任务

  ```java
  ExecutorService pool = Executors.newSingleThreadExecutor();
  ```

- **newWorkStealingPool**  足够大小的线程池 jdk8新增

  newWorkStealingPool创建持有足够线程的线程池来达到快速运算的目的，在内部通过使用多个队列来减少各个线程调度产生的竞争。这里所说的有足够的线程指JDK根据当前线程的运行需求向操作系统申请足够的线程，以保障线程的快速执行，并很大程度地使用系统资源，提高并发计算的效率，省去用户根据CPU资源估算并行度的过程

  ```java
  ExecutorService pool = Executors.newWorkStealingPool();
  ```

### 线程生命周期

#### 线程生命周期流程

- 调用new方法新建一个线程, 线程进入新建状态
- 调用start方法启动一个线程, 线程进入就绪状态
- 处于就绪状态的线程等待线程获取cpu资源, 获取资源后, 进入运行状态
- 正在运行状态的线程, 调用了yield方法, 或者失去cpu资源, 会再次进入就绪状态
- 正在运行状态的线程, 调用了sleep方法, I/O阻塞, 等待同步锁, 等待通知, 调用suspend方法等操作后, 会挂起并进入阻塞状态, 进入blocked池.
- 阻塞状态的线程, 由于sleep时间已到,I/O方法返回结果, 获得同步锁, 收到通知, 调用resume方法等情况, 会再次进入到就绪状态, 等待cpu时间片的轮询, 获取cpu资源后, 再次进入到运行状态.

## CAS(CompareAndSet)

比较并交换

```java
public class CASDemo {
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(5);
        // compareAndSet 方法第一个参数为期望值, 当atomicInteger的当前值和期望值相同的时候, 再去用第二个参数去修改, 
        // 修改成功返回true
        System.out.println(atomicInteger.compareAndSet(5, 2021) + "\t" + atomicInteger.get());
        // 因为第一次已经将atomicInteger修改为2021, 所以第二次与期望值比较时, 发现不同, 就不会再修改为2022
        System.out.println(atomicInteger.compareAndSet(5, 2022) + "\t" + atomicInteger.get());
    }
}
```

低层是使用Unsafe类, Unsafe类的各个方法都是native方法, 他会通过内存偏移量(地址)直接操作内存, 在操作的过程中不允许被中断, 其他要执行相同的操作的线程会被挂起, 也就是说cas是一条cpu的原子指令, 不会参数所谓的数据不一致的问题

```java
// AtomicInteger类源码
public final int getAndIncrement(){
    // 使用unsafe类的方法, this表示当前对象, valueOffset是内存偏移量, 1表示自增1
    return unsafe.getAndAddInt(this, valueOffset, 1);
}

// unsafe类源码
// var1是传入的对象, var2是内存偏移量, var4是要增加的值
public final int getAndAddInt(Object var1, long var2, int var4){
    int var5;
    do {
        // 获取当前的值, 此时如果有其他线程在执行this.compareAndSwapInt, 那么此线程在获取值后, 被挂起
        var5 = this.getIntVollatile(var1, var2);
        // 调用了unsafe的cas方法, var5是期望的值, 与var1对象的var2地址的值比较, 相同则修改 
    }while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
}
```



### 为什么不使用synchronized, 而使用CAS

因为synchronized加了同步锁, 降低了并发性, 而CAS保证了一致性, 有提高了并发性 

### CAS缺点

1. 循环时间长, 开销大,

   可能每次比较都不成功, 就会一直自旋

2. 只能保证一个共享变量的原子操作

   如果一个方法要操作多个变量, 就只能加锁

3. 引发ABA问题

   ABA问题, 有一个变量x=A,  线程1处理变量要用10s, 线程2处理变量要用2S, 线程2短时时间内将x变为B, 又变为A, 线程1再获取到A以为没有发生修改 

### 原子引用

对自定义的类包装成,原子类

```java
class User{
    private String username;

    public User(String username) {
        this.username = username;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    @Override
    public String toString() {
        return "User{" +
                "username='" + username + '\'' +
                '}';
    }
}


public class AtomicReferenceDemo {
    public static void main(String[] args) {
        // 将user包装到一个原子引用
        AtomicReference<User> userAtomicReference = new AtomicReference<>();
        User user1 = new User("张三");
        User user2 = new User("李四");
        userAtomicReference.set(user1);

        System.out.println(userAtomicReference.compareAndSet(user1, user2) + " \t" + userAtomicReference.get().toString());
        System.out.println(userAtomicReference.compareAndSet(user1, user2) + " \t" + userAtomicReference.get().toString());
    }
}

```

### 解决ABA问题

在修改值的时候, 增加其版本号, 类似于乐观锁 线程1获取A的时候版本号为1, 修改为B的时候版本号为2, 再修改为A, 版本号为3, 

线程2一开始也获取的版本号是1, 但是要修改的时候再获取一次, 版本号为3, 就需要自旋重新获取

```java
public class ABADemo {

    static AtomicReference<Integer> atomicReference = new AtomicReference<>(100);
    // AtomicStampedReference类带有版本属性, 参数2是初始版本号
    static AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(100, 1);

    public static void main(String[] args) {
        // ========= 演示ABA问题================
//        new Thread(() -> {
//            atomicReference.compareAndSet(100, 101);
//            atomicReference.compareAndSet(101, 100);
//        } ,"thread1").start();
//        new Thread(() -> {
//            try {
//                // 保证线程1, 完成一次aba操作
//                TimeUnit.SECONDS.sleep(1);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
//
//            System.out.println(atomicReference.compareAndSet(100, 10000) + "\t" + atomicReference.get());
//        } ,"thread2").start();

        // =========解决aba问题===============
        new Thread(() -> {
            int stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName() + "\t 第一次版本号:" + stamp);
            try {
                // 保证线程4, 拿到相同版本号
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            atomicStampedReference.compareAndSet(100, 101, stamp, ++stamp);
            System.out.println(Thread.currentThread().getName() + "\t 第二次版本号:" + stamp);
            atomicStampedReference.compareAndSet(101, 100, stamp, ++stamp);
            System.out.println(Thread.currentThread().getName() + "\t 第三次版本号:" + atomicStampedReference.getStamp());
        } ,"thread3").start();
        new Thread(() -> {
            int stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName() + "\t 第一次版本号:" + stamp);
            try {
                // 保证线程3, 完成一次aba操作
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 修改失败, 因为版本号再线程3中已经发生变化到3, 但是当前在线程4中还是1
            boolean b = atomicStampedReference.compareAndSet(100, 10000, stamp, ++stamp);
            System.out.println(b + "\t" +Thread.currentThread().getName() + "\t 第二次真实版本号:" + atomicStampedReference.getStamp());
            System.out.println(Thread.currentThread().getName() + "\t" + atomicStampedReference.getReference());
        } ,"thread4").start();
    }
}

```

## 公平和非公平锁

#### 解释

**公平锁**

多个线程按照申请锁的顺序来获取锁

**非公平锁**

多个线程获取锁的顺序并不是按照申请锁的顺序, 可能会造成优先级反转或者饥饿现象

非公平锁会尝试占有锁, 占有失败, 会再采用公平锁的方式

Synchronized是非公平锁

- **优点**  比公平锁吞吐量大, 性能好

```java
// true是公平锁, false是非公平锁, 默认是非公平
Lock lock = new ReentrantLock(true);
```

## 可重入锁(递归锁)

同一线程外城函数获得锁之后, 内层递归函数仍然能获取该锁的代码

在同一个线程在外层方法获取锁的时候, 在进入内层方法会自动获取锁

Synchronized和ReentrantLock都是可重入锁

**作用:**   避免死锁, 递归调用自己的时候, 如果不可重入, 就会死锁

```java
class Phone implements Runnable{
    public synchronized void sendMsg(){
        System.out.println(Thread.currentThread().getId() + "\t sendMsg");
        sendEmail();
    }
    public synchronized void sendEmail(){
        System.out.println(Thread.currentThread().getId() + "\t sendEmail");
    }
    Lock lock = new ReentrantLock();
    @Override
    public void run() {

    }
    public void get(){
        // 加几次锁都可以正常运行, 加几次锁就要释放几次, 否则别的线程无法获取锁
        // lock.lock();
        lock.lock();
        try{
            System.out.println(Thread.currentThread().getId() + "\t set");
            set();
        }finally {
            // lock.unlock();
            lock.unlock();
        }
    }

    public void set(){
        lock.lock();
        try{
            System.out.println(Thread.currentThread().getId() + "\t get");
        }finally {
            lock.unlock();
        }
    }
}
public class ReenterLockDemo {
    public static void main(String[] args) {
        Phone phone = new Phone();
        // t1 t2用的synchronized
        new Thread(() -> {
            phone.sendMsg();
        }, "t1").start();

        new Thread(() -> {
            phone.sendMsg();
        }, "t2").start();
		// t3 t4用的lock
        new Thread(() -> {
            phone.get();
        }, "t3").start();

        new Thread(() -> {
            phone.get();
        }, "t4").start();
    }
}
```

## 自旋锁

尝试获取锁的线程不会立即阻塞, 而是采用循环的方式去尝试获取锁, 这样的好处是减少线程上下文切换的消耗, 缺点是循环会消耗cpu

```java
// 自定义自旋锁
public class SpinLockDemo {
    // 原子引用线程
    AtomicReference<Thread> atomicReference = new AtomicReference<>();
    // 加锁
    public void myLock(){
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName() + "come in");

        // 新进来的原子引用是空的, 将当前线程放入原子引用中
        // 要取反表示原子引用中已有线程, 不需要循环
        // 第二个线程再进来, 原子引用不是null, 所以会设置失败, 继续循环
        while (!atomicReference.compareAndSet(null, thread)){

        }
    }
    // 释放锁
    public void myUnLock(){
        // 将原子引用释放
        Thread thread = Thread.currentThread();
        atomicReference.compareAndSet(thread, null);
        System.out.println(thread.getName() + "come out");
    }

    public static void main(String[] args) {
        SpinLockDemo spinLockDemo = new SpinLockDemo();
        new Thread(() -> {
            // 获取锁,之后不释放锁
            spinLockDemo.myLock();
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 释放锁
            spinLockDemo.myUnLock();
        }, "t1").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            spinLockDemo.myLock();
            spinLockDemo.myUnLock();
        }, "t2").start();
    }
}
```

## 独占锁(写锁)/共享锁(读锁)/互斥锁

- **独占锁**   Synchronized和ReentrantLock都是独占锁, 一次只能被一个线程持有
- **共享锁**   可以同时被多个线程持有, 对于**ReentrantReadWriteLock**读锁是共享锁, 写锁是独占锁

读锁的共享锁, 能保证并发读是非常高效的, 读写, 写读, 写写的过程是互斥的

```java
class MyCahce{
    private volatile Map<String, Object> map = new HashMap<>();
    // 读写锁
    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    public void set(String key, Object value){
        // 如果不加锁, 可能会连续打印正在写入, 违反了原子性, 一次操作, 不应该允许其他操作插入
        // 读写锁设置写锁
        lock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "正在写入" + key);
            try {
                TimeUnit.MICROSECONDS.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + "写入完成" + key);
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.writeLock().unlock();
        }
    }

    public Object get(String key){
        // 读写锁设置写锁
        lock.readLock().lock();
        try{
            System.out.println(Thread.currentThread().getName() + "正在读取" + key);
            try {
                TimeUnit.MICROSECONDS.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Object object =  map.get(key);
            System.out.println(Thread.currentThread().getName() + "读取完成" + key);
            return object;
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.readLock().unlock();
        }
        return null;
    }

    public void clear(){
        map.clear();
    }

}

public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCahce myCahce = new MyCahce();
        for (int i = 0; i < 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                myCahce.set(tempInt + "", tempInt + "");
            }, "thread" + i).start();
        }

        for (int i = 0; i < 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                myCahce.get(tempInt + "");
            }, "thread" + i).start();
        }
    }
}
```

## 计数器

### CountDownLatch

给定一个数量, 减到0之前阻塞

让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒

```java
public class CountDownLatchDemo {
    public static void main(String[] args) {
        // 计数器
        CountDownLatch count = new CountDownLatch(6);
        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "离开教室");
                // 执行一次-1
                count.countDown();
            }, String.valueOf(i)).start();
        }

        try {
            // 当count=0时, 才允许往下走, 不然一直等待
            count.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "锁门");
    }
}
```

### CyclicBarrier

加到指定数量之间阻塞

可循环使用的屏障, 

```java
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        // 第二个参数是, 满足指定数量后的, 回调方法
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
            System.out.println("********召唤神龙**********");
        });

        for (int i = 0; i < 7; i++) {
            final int tempInt = i;
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "\t 收集到" + tempInt + "龙珠");
                try {
                    // 先到的会在这里等待, 当全部完成后, 先执行声明的回调方法, 再全部线程全部放开阻塞, 继续执行
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
                 System.out.println(Thread.currentThread().getName() + "\t 召唤神龙");
            }, String.valueOf(i)).start();
        }
    }
}
```

## 信号量

多个线程抢购多个资源, 一个用于过多个共享资源互斥使用, 另一个用于并发线程控制

 ```java
public class SemaphoreDemo {
    public static void main(String[] args) {
        // 设置3个资源
        Semaphore semaphore = new Semaphore(3);
        // 6个线程去抢资源
        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                try {
                    // 占用资源, 当信号量的资源都被占用后, 其他线程进来会被阻塞, 等到有资源被释放掉
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + "\t 抢到车位");
                    TimeUnit.SECONDS.sleep(3);
                    System.out.println(Thread.currentThread().getName() + "\t 停车3秒后离开车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    // 释放资源
                    semaphore.release();
                }
            }, String.valueOf(i)).start();
        }
    }
}
 ```

## 阻塞队列

当阻塞队列是空的时候, 从队列获取元素的操作将会被阻塞

当阻塞队列是满的时候, 往队列添加元素的操作将会被阻塞

### 阻塞队列好的一面

不用关心,什么时候需要阻塞线程, 什么时候需要唤醒线程, 都是自动的

### 不得不阻塞, 如何管理

### 常用的阻塞队列

- **===============重点=================**

- **ArrayBlockingQueue**：基于数组数据结构实现的有界阻塞队列。

  ```java
  public class BlockingQueueDemo {
      public static void main(String[] args) {
          BlockingQueue<String> blockingQueue =new ArrayBlockingQueue<>(3);
          // add和remove, element当队列已满或者空的时候, 会抛出异常
          System.out.println(blockingQueue.add("a"));
          System.out.println(blockingQueue.remove());
          System.out.println(blockingQueue.element());
          
          // offer当队列已满返回false,
          System.out.println(blockingQueue.offer("a"));
          // poll当队列空的时候, 会返回null
          System.out.println(blockingQueue.poll());
          // peek查看队列顶的元素, 如果队列为空, 返回null
          System.out.println(blockingQueue.peek());
          
          // offer当队列已满阻塞指定时间,还没将数据插入, 会返回false
          System.out.println(blockingQueue.offer("a", 2, TimeUnit.SECONDS)));
          // poll当队列空的时候阻塞指定时间,如果队列还为空, 会返回null
          System.out.println(blockingQueue.poll());
          
          // put当队列已满, 会阻塞,
          System.out.println(blockingQueue.put("a"));
          // poll当队列空的时候, 会阻塞
          System.out.println(blockingQueue.take());
      }
  }
  ```

- **LinkedBlockingQueue**：基于链表数据结构实现的有界阻塞队列(默认大小是Integer.MAX_VALUE), **慎用, 需要指定大小, 不指定大小就是无界队列**。

- **SynchronousQueue**：用于线程同步的阻塞队列。只能存一个元素.

  ```java
  public class SynchronousQueueDemo {
      public static void main(String[] args) {
          BlockingQueue queue = new SynchronousQueue();
          new Thread(() -> {
              try {
                  // 一次只能存入一个元素, 当队列已满就会阻塞
                  System.out.println(Thread.currentThread().getName() + "\t put1");
                  queue.put("1");
                  System.out.println(Thread.currentThread().getName() + "\t put2");
                  queue.put("2");
                  System.out.println(Thread.currentThread().getName() + "\t put3");
                  queue.put("3");
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }, "AAA").start();
  
          new Thread(() -> {
              try {
                  TimeUnit.SECONDS.sleep(1);
                  System.out.println(Thread.currentThread().getName() + "take" + queue.take());
                  TimeUnit.SECONDS.sleep(1);
                  System.out.println(Thread.currentThread().getName() + "take" + queue.take());
                  TimeUnit.SECONDS.sleep(1);
                  System.out.println(Thread.currentThread().getName() + "take" + queue.take());
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }, "BBB").start();
      }
  }
  ```

  

- **==============非重点================**

- **PriorityBlockingQueue**：支持优先级排序的无界阻塞队列。

- **DelayQueue**：支持延迟操作的无界阻塞队列。

- **LinkedBlockingDeque**：基于链表数据结构实现的双向阻塞队列。

- **LinkedTransferQueue**：基于链表数据结构实现的无界阻塞队列。当队列中无元素时, 消费线程取元素, 队列会生成一个空节点, 消费线程等待这个节点, 后面

  生产线程要加入队列时, 发现空节点, 就不入队, 直接填充到空节点上, 唤醒消费线程消费.相对于LinkedBlockingQueue效率更高

## 生产者消费者

### 锁实现

```java
class ShareData{
    private int num = 0;
    private Lock lock = new ReentrantLock();
    // 创建一个锁的状态控制类, 可以阻塞, 唤醒线程
    private Condition condition = lock.newCondition();
    public void increment(){
        lock.lock();
        try {
            // 必须使用while判断, 不是使用if, 避免线程虚假唤醒
            while (num != 0){
                // 等待不能生产
                condition.await();
            }
            num++;
            System.out.println(Thread.currentThread().getName() + "\t" + num);
            // 通知唤醒全部线程, 目的唤醒decrement阻塞的线程,去消费
            condition.signalAll();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void decrement(){
        lock.lock();
        try {
            while (num == 0){
                // 等待不能消费
                condition.await();
            }
            num--;
            System.out.println(Thread.currentThread().getName() + "\t" + num);
            // 通知唤醒全部线程, 目的唤醒increment中的线程去,生产
            condition.signalAll();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}


public class ProdConsumer_TraditionDemo {
    public static void main(String[] args) {
        ShareData shareData = new ShareData();
        new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                shareData.increment();
            }
        }, "AA").start();

        new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                shareData.decrement();
            }
        }, "BB").start();
    }
}
```

### 阻塞队列实现

```java
class MyResource{
    private volatile boolean FLAG = true;  // 默认开启, 进行生产和消费, vloatile修饰, 发生修改时, 立刻通知别的线程
    private AtomicInteger atomicInteger = new AtomicInteger();  // 原子类
    private BlockingQueue<String> blockingQueue = null;  // 存放数据
	
    public MyResource(BlockingQueue<String> blockingQueue) {
        this.blockingQueue = blockingQueue;
    }

    public void myProd() throws InterruptedException {
        String data;
        boolean retValue;
        while (FLAG){
            data = String.valueOf(atomicInteger.incrementAndGet());
            retValue = blockingQueue.offer(data, 2, TimeUnit.SECONDS);
            if (retValue){
                System.out.println(Thread.currentThread().getName() + "\t 插入队列" + data + "成功");
            }else{
                System.out.println(Thread.currentThread().getName() + "\t 插入队列" + data + "失败");
            }
            TimeUnit.SECONDS.sleep(1);
        }
        System.out.println(Thread.currentThread().getName()+ "\t 生产结束");
    }

    public void myConsumer() throws InterruptedException {
        String data;
        while (FLAG){
            data = blockingQueue.poll(2, TimeUnit.SECONDS);
            if (data == null || data.equalsIgnoreCase("")){
                FLAG = false;
                System.out.println(Thread.currentThread().getName() + "\t 超过2s没有取到蛋糕, 消费退出");
                return;
            }
            System.out.println(Thread.currentThread().getName() + "\t 消费队列" + data + "成功");
        }
    }

    public void stop(){
        FLAG = false;
    }
}

public class ProdConsumer_BlockQueueDemo {
    public static void main(String[] args) {
        MyResource myResource = new MyResource(new ArrayBlockingQueue<>(10));
        new Thread(() -> {
            System.out.println("生产者线程启动");
            try {
                myResource.myProd();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Prod").start();

        new Thread(() -> {
            System.out.println("消费者线程启动");
            try {
                myResource.myConsumer();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Consumer").start();

        try {
            TimeUnit.SECONDS.sleep(5);
            System.out.println("5s时间到, 结束");
            myResource.stop();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```



## Synchronized和lock的区别

|                  |                         Synchronized                         |                             lock                             |
| :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   **原始构成**   | 属于JVM层面,是java的关键字<br />低层是monitorneter和monitorexit |                      API层面, 是一个类                       |
|   **使用方法**   |               不需要用户手动释放, 不会产生死锁               |                         需要手动释放                         |
|  **是否可中断**  |            不可中断, 除非抛出异常或者正常运行完成            | 可中断, 可以通过tryLock()设置锁的超时时间, <br />或者lock.lockInterruptibly()加锁的代码中, 通过线程的interrupt()中断 |
| **加锁是否公平** |                            非公平                            |         默认非公平, new ReentrantLock(true)为公平锁          |
|  **Condition**   |          没有, Synchronized只能全部唤醒或者随机唤醒          |         用来实现分组唤醒需要唤醒的线程, 可以精确唤醒         |

```java
// 多线程之间按顺序调用, 实现A->B->C三个线程启动, 要求如下
// AA打印5次, BB打印10次, CC打印15次, 重复10轮
class ShareResource{
    private int num = 1; // A:1, B:2, C: 3
    private Lock lock = new ReentrantLock();
    // 指定三个条件, 分别对应三个线程
    private Condition[] conditions = {lock.newCondition(), lock.newCondition(), lock.newCondition()};

    // code表示, 当前是谁在调用
    public void print(int code){
        lock.lock();
        try {
            // 不是要打印的线程, 就让他挂起
            while (num != code){
                conditions[code-1].await();
            }
            for (int i = 0; i < 5 * code; i++) {
                System.out.println(Thread.currentThread().getName() + "\t" + (i+1));
            }
            num = ++num > 3 ? 1 : num;
            // 唤醒指定线程
            conditions[num-1].signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
public class SyncAndReetracntLockDemo {
    public static void main(String[] args) {
        ShareResource shareResource = new ShareResource();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                shareResource.print(1);
            }
        }, "AA").start();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                shareResource.print(2);
            }
        }, "BB").start();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                shareResource.print(3);
            }
        }, "CC").start();
    }
}
```



# 事务

## 事务的传播属性

- **@Transactional(propagation=Propagation.REQUIRES)**   默认

```java
// propagation=Propagation.REQUIRES 会让里面带事务的方法执行时, 共用外部方法的事务
@Transactional(propagation=Propagation.REQUIRES)
public void buy(){
    // 第一次操作成功
    updateCount();
    // 第二次操作失败, 会将第一次的操作也进行回滚, 因为共用buy方法的事务
    updateCount();
}
@Transactional
public void updateCount(){}
```

- **@Transactional(propagation=Propagation.REQUIRES_NEW)**

```java
// propagation=Propagation.REQUIRES_NEW 会让里面带事务的方法执行时, 开启自己的独立事务
@Transactional(propagation=Propagation.REQUIRES_NEW)
public void buy(){
    // 进行第一次操作, buy方法的事务挂起, 开启第一次操作的事务, 第一次操作成功, 事务结束, buy方法的事务继续
    updateCount();
    // 进行第二次操作, buy方法的事务挂起, 开启第二次操作的事务, 第二次操作失败, 不会影响到第一次操作, 因为第一次操作的事务已经提交, 事务有隔离性
    updateCount();
}
@Transactional
public void updateCount(){}
```

## 数据库事务并发问题

有两个事务**Transactional01**和**Transactional02**并发执行

### 脏读

- T1将一条记录的数值从20变为30
- T2读取了30
- T1回滚了, 30变为20
- T2读到的30就是一个无效的值

### 不可重复读

- T1读取到的值是20
- T2将值改为30
- T1再次读取值为30, 和第一次读取的不同, 为不可重复读

### 幻读

- T1从表中读取了一条数据
- T2向表中插入了一条新数据
- T1再读, 数据量和第一次不同

## 数据库隔离级别

### 读未提交(READ   UNCOMMITTED)

T2允许读到T1未提交的数据

### 读已提交(READ   COMMITTED)

T2只能读取到T1已提交的数据, **解决了脏读**

### 可重复读(REPEATABLE   READ)

确保T1可以多次从一个字段中读取到相同的值, 即T1的执行期间, 其他事务无法对T1读取的字段做修改, **解决了脏读, 不可重复读**

### 串行化(SERIALIZABLE)

确保T1可以多次从一张表中读取到相同的行, 在T1执行期间, 进行其他事务对这个表进行添加, 更新, 删除操作

可以避免任何并发问题, 但是性能很差, **解决了脏读, 幻读, 不可重复读**

## 各种数据库对隔离级别的支持

|                              | Oracle  |  MySQL  | SQL Server |
| :--------------------------: | :-----: | :-----: | :--------: |
| 读未提交(READ   UNCOMMITTED) |         |    √    |     √      |
|  读已提交(READ   COMMITTED)  | √(默认) |    √    |  √(默认)   |
| 可重复读(REPEATABLE   READ)  |         | √(默认) |     √      |
|     串行化(SERIALIZABLE)     |    √    |    √    |     √      |

## 修改事务隔离级别

```java
// 修改为读已提交
@Transactional(isolation=Isolation.READ_COMMITTED)
```

# NoSQL

## Redis

### redis持久化方式

- RDB默认的持久化方式, fork一个进程, 如果在一段时间内修改了n条数据, 这个进程就会将内存中的全量数据, 保存到持久化的文件中
  - **优点**: 性能好, 占用的空间小, redis重启服务时, 恢复数据快
  - **缺点**: 如果在没达到触发持久化的条件, redis服务异常, 内存这段时间的新数据会丢失, 当数据量大的时候, 因为是全量替换, 会影响性能 
- AOF, 每次发生写的操作, 都会记录一条操作日志, 通过日志持久化数据
  - **优点:** 数据安全性比RDB要好, 日志文件可读, 可以处理误操作
  - **缺点:** 日志占用空间大, 数据a修改了20次, 就要记录20次, 实际只会用到最后一次, 恢复数据慢, 每次都读写同步, 有性能压力

# Git

## 命令

### 分支

#### 创建分支

```bash
 git branch <分支名>
```

#### 查看分支

```bash
git branch -v
```

#### 切换分支

```bash
git checkout <分支名>
# 创建分支并切换到这个分支, 推荐使用
git checkout -b <分支名>
```

#### 合并分支

```bash
# 先切换到分支1
git checkout <分支名1>
# 将分支2的代码合并到分支1
git merge <分支名2>
```

#### 删除分支

```bash
# 切换到主分支
git checkout master
# 删除分支
git branch -D <分支名>
```



## git分支流程

- master分支, 上线用的分支, 不会直接在master分支上修改代码
- 通过master分支创建一个主开发分支
- 在主开发分支创建多个模块分支
- 模块分支开发完成, 合并到主开发分支
- 主开发分支, 创建一个测试分支
- 测试分支的代码通过后, 合并到master分支, 和主开发分支, 保持master和主开发分支代码一致
- 如果master分支发现bug, 在master分支上创建一个临时分支, 解决完bug后, 合并到master分支上和主开发分支上

# 分布式系统

## 为什么需要分布式全局唯一ID以及分布式ID的业务需求

如果搭建了集群环境并且分库分表, 很容易出现相同的ID

需要专门的ID服务器, 生成全局分布式唯一ID, 该服务器需要满足

- **高可用**

  发一个分布式ID的请求, 服务器就要保证99.999%的情况下给我创建一个唯一分布式ID

- **低延迟**

  发一个获取分布式ID的请求, 服务器要快速响应

- **高QPS**

  要满足短时间大量(10万+)的请求

### UUID

UUID是无序的, 无法预测生成顺序, 入库性能较差, 创建的也会消耗更多时间, 减少插入性能, 并且32位较长

### 自增主键

#### 单机

单机模式可以使用

```sql
# 是同replace into 语句, 用法和insert into 相同,
# 不同点是, 检测到唯一索引那列冲突, 会删除当前数据, 再插入新数据, 自增主键会正常增加
replace into 
```

#### 集群

不太适合, 不容易扩展, 分库分表会出现自增要设置不同的步长的问题, 数据库压力过大

### 基于Redis生成全局id策略

Redis自带的**INCR**和**INCRBY**都是原子性操作, 并且性能高, 比关系型数据库更适合做全局唯一主键生成,

但是如果部署Redis集群, 还是很难解决, 每个Redis的自增设置不同的步长问题

### 雪花算法(推荐)

- 生成的id的结果是一个64bit大小的整数, 为一个Long型(转换成字符串, 最大不会超过19位)
- 分布式系统不会产生ID碰撞, 并且效率较高
- 毫秒数在高位, 整体是趋势递增的, 随着时间戳增大
- 不依赖第三方数据库系统
- 可以根据自身的特性分配他的工作进程位

#### 号段解释

雪花算法生成的id,转换成2进制为, 64为

- **第一位**   符号位, 基本永远是0, 0为正数, ID一般不会存在负数
- **2-42位**   时间戳, 能使用69.73年, 一直到2039年
- **43-52位**   工作进程位, 表示工作的机器ID, 最多1024台,  workerId和datacenterId
- **53-64位**   序列号, 用来记录毫秒内产生的不同ID

#### 缺点

- 依赖时钟, 如果服务器的时间往回调整, 可能会出现生成重复ID的情况
- 在单机上是呈现递增的, 但是在分布式环境上, 不同服务器的时间可能不同, 有时候不会出现全局递增的情况

#### 雪花算法优化

- UidGenerator(百度)
- Leaf(美团)

## ID生成规则部分硬性要求

- **全局唯一**

- **趋势递增**

  MySQL的innoDB引擎使用的是聚集索引, 由于多数RDBMS使用的Btree的数据结果来存储索引数据, 在主键的选择上, 我们尽可能选择有序的主键, 保证性能

- **单调递增**

  保证下一个ID一定大于上一个ID, 例如事务的版本号, IM增量信息, 排序等特殊需求

- **信息安全**

  如果ID是连续的容易被人恶意爬取, 所以尽量使用无规则的ID

- **含时间戳**
