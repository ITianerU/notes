**题目来源**

[力扣（LeetCode）](https://leetcode-cn.com/)

[TOC]



# 简单(41-60)

## 1.[Excel表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)

**描述**

给定一个Excel表格中的列名称，返回其相应的列序号。

例如，

    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...

**示例**

**示例 1:**

```
输入: "A"
输出: 1
```

**示例 2:**

```
输入: "AB"
输出: 28
```

**示例 3:**

```
输入: "ZY"
输出: 701
```

**题解**

**Java**

```java
class Solution {
    // 26进制转换为10进制
    public int titleToNumber(String s) {
        int res = 0;
        for(int i=0; i<s.length(); i++){
            int tmp = s.charAt(i) - 64;
            res = tmp + res * 26;
        }
        return res;
    }
}
```

## 2.[阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

**描述**

给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**示例**

示例 1:

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```


示例 2:

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

**说明**: 

你算法的时间复杂度应为 O(log n) 。

**题解**

**Java**

```java
class Solution {
    public int trailingZeroes(int n) {
        int zeroCount = 0;
        // 每有一个5, 就会多一个0
        while(n > 0){
            n /= 5;
            zeroCount += n;
        }
        return zeroCount;
    }
}
```

## 3.[旋转数组](https://leetcode-cn.com/problems/rotate-array/)

**描述**

给定一个数组，将数组中的元素向右移动 *k* 个位置，其中 *k* 是非负数。

**示例**

示例 1:

```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

示例 2:

```
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```

**说明**: 

- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 要求使用空间复杂度为 O(1) 的 **原地** 算法。

**题解**

**Java**

```java
// 环状替换
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;
        // 该count, 统计遍历的次数
        int count = 0;
        // k 有可能超出数组的长度, 造成无效循环, 所以取余
        k = k % len; 
        // nums : [1,2,3,4,5,6]   k : 2
        // 1->3 3->5 5->1 这样替换最终又会回到起点, 所以下方让cur=start, 当cur==start时, 结束do-while循环
        // start进行加一
        for(int start=0; count<len; start++){
            int cur = start;
            int current = nums[start];
            do{
                // 算出, 要被替换的点的位置
                int next = (cur+k) % len;
                // 取出, 被替换的数
                int tmp = nums[next];
                // 替换
                nums[next] = current;
                current = tmp;
                cur = next;
                count++;
            }while(cur != start);
        }
    }
}
// 翻转
class Solution {
    public void rotate(int[] nums, int k) {
        // nums = [1,2,3,4,5,6], k = 2
        k = k % nums.length;
        // 第一次翻转, 将数组全部翻转
        // nums = [6,5,4,3,2,1]
        reverse(nums, 0, nums.length-1);
        // 第二次, 将0-k翻转
        // nums = [5,6,4,3,2,1]
        reverse(nums, 0, k-1);
        // 第三次, 将后面的翻转
        // nums = [5,6,1,2,3,4]
        reverse(nums, k, nums.length-1); 
    }
    public void reverse(int[] nums, int start, int end) {
        while(start < end){
            int tmp = nums[start];
            nums[start] = nums[end];
            nums[end] = tmp;
            start++;
            end--;
        }
    }
}
```

## 4.[打家劫舍](https://leetcode-cn.com/problems/house-robber/)

**描述**

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例**

示例 1:

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

示例 2:

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**说明**: 

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

**题解**

**Java**

```java
class Solution {
    /*
    *  动态规划
    *  因为不能连续偷两家的钱, 所以偷n家的钱,最优解就是就是Max(nums[n-2] + nums[n], nums[n-1])中的最大值
    *  例子: n = 1 时, 最大值是nums[1]
    *       n = 2 时, 最大值是 max(nums[1], nums[2])
    *       n = 3 时, 最大值是 max(nums[3] + nums[3-2], nums[3-1])
    *       n = 4 时, 最大值是 max(nums[4] + nums[4-2], nums[4-1])
    *  每一次遍历, 都取之前的最优解,加上新值做比较
    */
    public int rob(int[] nums) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        if(nums.length == 1){
            return nums[0];
        }
        if(nums.length == 2){
            return Math.max(nums[0], nums[1]);
        }
        // first和seonde保存最近的两次最优解
        int first = nums[0];
        int second = Math.max(nums[0], nums[1]);
        for(int i=2; i<nums.length;i++){
            int tmp = second;
            second = Math.max(nums[i] + first, second);
            first = tmp;
        }
        return second;
    }
}
```

## 5.[快乐数](https://leetcode-cn.com/problems/happy-number/)

**描述**

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。

**示例**

```
输入：19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**题解**

**Java**

```java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> set = new HashSet<>();
        while(n != 1){
            // 判断该数字是否已遍历过, 已遍历过, 说明会无限循环, return false
            if(set.contains(n)){
                return false;
            }
            set.add(n);
            int tmp = n;
            n = 0;
            // 将数字每一位平方相加
            while(tmp != 0){
                int d = tmp % 10;
                n += d * d;
                tmp /= 10;
            }   
        }
        return true;
    }
}
```

## 6.[移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

**描述**

删除链表中等于给定值 **val** 的所有节点。

**示例**

```
输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
```

**题解**

**Java**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    // 哨兵模式
    public ListNode removeElements(ListNode head, int val) {
        // 定义一个前置节点
        ListNode sentinel = new ListNode(0);
        sentinel.next = head;
        // tmp指向前置节点
        ListNode tmp = node;
        while(head != null){
            // 当头节点的值为要删除的值, 让前置节点的下一个值, 为头节点的下一个值, 头节点指向下一个节点
            // 当头节点的值不为要删除的值, 前置节点指向头节点, 头节点指向下一个节点
            if(head.val == val){
                tmp.next = head.next;
            }else{
                tmp = head;
            }
            head = head.next;
        }
        return sentinel.next;
    }
}
```

## 7.[计数质数](https://leetcode-cn.com/problems/count-primes/)

**描述**

统计所有小于非负整数 *n* 的质数的数量。

**示例**

```
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

**题解**

**Java**

```java
class Solution {
    /* 
    * 排除法
    * 1. 排除掉大于2的偶数
    * 2. 从3开始, 排除掉3的奇数倍, 5的奇数倍, 6的奇数倍
    * 3. 这些数都排除后, 剩下的数量就是质数的数量
    */
    public int countPrimes(int n) {
        if(n <= 2){
            return 0;
        }
        int count = n / 2;
        boolean[] isPrimes = new boolean[n]; 
        // i*i<n 表示遍历sqrt(n)次就可全部排除
        // i=i+2 表示每次遍历奇数
        for(int i=3; i*i<n; i=i+2){
            if(isPrimes[i]){
                continue;
            }
            // j=j+i*2 表示每次遍历奇数的奇数倍
            for(int j=i*i; j<n; j=j+i*2){
                if(!isPrimes[j]){
                    count--;
                    isPrimes[j] = true;
                }
            }
        }
        return count;
    }
}
```

## 8.[同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)

**描述**

给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。

所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。

**示例**

**示例 1:**

```
输入: s = "egg", t = "add"
输出: true
```

**示例 2:**

```
输入: s = "foo", t = "bar"
输出: false
```

**示例 3:**

```
输入: s = "paper", t = "title"
输出: true
```

**说明:**

你可以假设 ***s*** 和 **t** 具有相同的长度。

**题解**

**Java**

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        return isSame(s, t) && isSame(t, s);
    }
	/*
	*  将映射存到map中, 每次遍历字符, 去查有没有已经存在的映射关系, 如果有, 这个映射的值是否与当前值相等
	*  如果没有映射, 新建映射关系
	*/
    public boolean isSame(String s, String t){
        Map<Character, Character> map = new HashMap<>();
        for(int i=0; i<s.length(); i++){
            if(map.containsKey(s.charAt(i))){
                if(map.get(s.charAt(i)) != t.charAt(i)){
                    return false;
                }
            }else{
                map.put(s.charAt(i), t.charAt(i));
            }
        }
        return true;
    }
}
```

## 9.[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

**描述**

反转一个单链表。

**示例**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**进阶:**

你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

**题解**

**Java**

```java
class Solution {
    // 循环
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        while(head != null){
            ListNode node = head.next;
            head.next = pre;
            pre = head;
            head = node;
        }
        return pre;
    }
	// 递归
    public ListNode reverseList2(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode p = reverseList(head.next);
        // 让相邻两个节点, 翻转
        head.next.next = head;
        head.next = null;
        return p;
    }
}
```

## 10.[存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

**描述**

给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

**示例**

**示例 1:**

```
输入: [1,2,3,1]
输出: true
```

**示例 2:**

```
输入: [1,2,3,4]
输出: false
```

**示例 3:**

```
输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
```

**题解**

**Java**

```java
class Solution {
    // 先排序, 然后比较前后两个值
    public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums);
        for (int i = 0; i < nums.length - 1; ++i) {
            if (nums[i] == nums[i + 1]) return true;
        }
        return false;
    }
}
```

## 11.[存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

**描述**

给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。

**示例**

**示例 1:**

```
输入: nums = [1,2,3,1], k = 3
输出: true
```

**示例 2:**

```
输入: nums = [1,0,1,1], k = 1
输出: true
```

**示例 3:**

```
输入: nums = [1,2,3,1,2,3], k = 2
输出: false
```

**题解**

**Java**

```java
class Solution {
    // 将值和索引存储到map中,  判断相同得, 取出索引比较差值
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        int i=0;
        for(int num: nums){
            if(map.containsKey(num)){
                if(Math.abs(map.get(num) - i) <= k){
                    return true;
                }
            }
            map.put(num, i);     
            i++;
        }
        return false;
    }
}
```

## 12.[用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

使用队列实现栈的下列操作：

push(x) -- 元素 x 入栈
pop() -- 移除栈顶元素
top() -- 获取栈顶元素
empty() -- 返回栈是否为空
注意:

你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。
你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

**题解**

**Java**

```java
class MyStack {

    private Queue<Integer> q = new LinkedList<>();
    private int top;
    /** Initialize your data structure here. */
    public MyStack() {
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        // 每次新加元素, 颠倒顺序
        q.add(x);
        int size = q.size();
        while(size > 1){
            q.add(q.remove());
            size--;
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return q.remove();
    }
    
    /** Get the top element. */
    public int top() {
        return q.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return q.isEmpty();
    }
}
```

## 13.[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

翻转一棵二叉树。

**示例**

输入：

         4
       /   \
      2     7
     / \   / \
    1   3 6   9

输出：

          4
        /   \
      7      2
     / \    / \
    9   6  3   1

**备注:**
这个问题是受到 Max Howell 的 原问题 启发的 ：
谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。

**题解**

**Java**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    // 递归, 每个节点得左右子节点, 互换
    public TreeNode invertTree(TreeNode root) {
        if(root == null){
            return null;
        }
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        root.left = right;
        root.right = left;
        return root;
    }
}
```

## 14.[2的幂](https://leetcode-cn.com/problems/power-of-two/)

给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

**示例**

**示例一**：

```
输入: 1
输出: true
解释: 20 = 1
```

**示例二**：

```
输入: 16
输出: true
解释: 24 = 16
```

**示例三**：

```
输入: 218
输出: false
```

**题解**

**Java**

```java
class Solution {
    // 每次除2, 判断每次除后的结果
    public boolean isPowerOfTwo(int n) {
        while(n != 0){
            if(n == 2 || n == 1){
                return true;
            }
            if(n % 2 == 1){
                return false;
            }
            n = n / 2;
        }
        return false;
    }
}
```

## 15.[用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

使用栈实现队列的下列操作：

- push(x) -- 将一个元素放入队列的尾部。
- pop() -- 从队列首部移除元素。
- peek() -- 返回队列首部的元素。
- empty() -- 返回队列是否为空。

**示例**

```
MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
```

**说明:**

- 你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。

**题解**

**Java**

```java
class MyQueue {

    Stack<Integer> s1 = new Stack();
    Stack<Integer> s2 = new Stack();
    int front = 0;
    /** Initialize your data structure here. */
    public MyQueue() {}
    
    /** Push element x to the back of queue. */
    // s1若为空, 新加入的元素就为最前面的元素, 给front复制
    // s1若不为空, 就正常添加元素
    public void push(int x) {
        if (s1.empty()){
            front = x;
        }
        s1.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    // 如果s2为空,  s1不为空, 将s1取出放到s2里,  s1最后取出的元素, 到s2中就是最先取出的元素
    public int pop() {
        if (s2.isEmpty()) {
            while (!s1.isEmpty()){
                s2.push(s1.pop());
            }   
        }
        return s2.pop();
    }
    
    /** Get the front element. */
    // 如果s2不为空, s2的栈顶元素为, 队列的首元素
    public int peek() {
        if (!s2.isEmpty()) {
            return s2.peek();
        }
        return front;
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
         return s1.isEmpty() && s2.isEmpty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

## 16.[回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

请判断一个链表是否为回文链表。

**示例**

**示例 1:**

```
输入: 1->2
输出: false
```

**示例 2:**

```
输入: 1->2->2->1
输出: true
```

**说明:**

- **进阶：**
  你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

**题解**

**Java**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
// 找到中间节点, 将后面的链表翻转后, 与前面的比较
class Solution {
     public boolean isPalindrome(ListNode head) {
        if(head == null) return true;
        ListNode preHalfList = endOfFirstHalf(head);
        // 这里传入中间节点的下一个节点的原因是
        // 链表 1,2,3,3,2,1 的中间节点是, 第一个3, 如果传入的是, 3,3,2,1
        // 翻转后为 1,2,3,3 但是此时 head节点为1,2,3 两个长度不等遍历会报空指针异常
        ListNode nextHalfList = reverseList(preHalfList.next);
        boolean result = true;
        ListNode p1 = head;
        ListNode p2 = nextHalfList;
        while(result && p2 != null){
            if(p1.val != p2.val){
                result = false;
            }
            p1 = p1.next;
            p2 = p2.next;
        }
        return result;
    }
	// 翻转链表
    private ListNode reverseList(ListNode head) {
        ListNode prev = null;
        while (head != null) {
            ListNode nextTemp = head.next;
            head.next = prev;
            prev = head;
            head = nextTemp;
        }
        return prev;
    }
	
    // 通过快慢指针, 找到中间的节点
    private ListNode endOfFirstHalf(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast.next != null && fast.next.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

## 17.[二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

![1596679125827](../../notes\图片\面试\算法练习-简单-27.png)

**示例**

**示例 1:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

**示例 2:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

**题解**

**Java**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    /*
    *  二叉搜索树的特点,  左边子节点的值比父节点小,  右边子节点的值比父节点大
    *  利用这个特点, 两个子节点的值, 都比父节点小,  父节点就取其左子节点, 继续遍历
    *  两个子节点的值, 都比父节点大, 父节点就取其右子节点, 继续遍历
    *  如果, 不满足上面两个条件, 说明, 两个子节点,是在父节点的左右两边, 或者与父节点重合
    *  此时, 父节点就是子节点的最近公共祖先
    */
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        int pVal = p.val;
        int qVal = q.val;
        TreeNode node = root;
        while(node != null){
            int nVal = node.val;
            if(pVal > nVal && qVal > nVal){
                node = node.right;
            }else if(pVal < nVal && qVal < nVal){
                node = node.left;
            }else{
                return node;
            }
        }
        return null;
    }
}
```

## 18.[删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。

**示例**

**示例 1:**

```
输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

**示例 2:**

```
输入：head = [4,5,1,9], node = 1
输出：[4,5,9]
解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```

**说明:**

- 链表至少包含两个节点。
- 链表中所有节点的值都是唯一的。
- 给定的节点为非末尾节点并且一定是链表中的一个有效节点。
- 不要从你的函数中返回任何结果。

**题解**

**Java**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    // 将当前节点的值, 变为下一个节点得值
    // 将当前节点的下一个节点, 变为再下一个节点
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```

## 19.[有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词

**示例**

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2:**

```
输入: s = "rat", t = "car"
输出: false
```

**说明:**

- 你可以假设字符串只包含小写字母。

**题解**

**Java**

```java
class Solution {
    // 将字符串转化为数组, 比较两个排序后的数组
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        char[] str1 = s.toCharArray();
        char[] str2 = t.toCharArray();
        Arrays.sort(str1);
        Arrays.sort(str2);
        return Arrays.equals(str1, str2);
    }
}
```

## 20.[二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

给定一个二叉树，返回所有从根节点到叶子节点的路径。

**示例**

**示例 1:**

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

**说明:**

- 叶子节点是指没有子节点的节点。

**题解**

**Java**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    // 递归, 先判断当前节点是否为叶子节点, 不是叶子节点, 就先拼接字符串, 是叶子节点, 再存到list中
    public void construct_paths(TreeNode root, String path, LinkedList<String> paths) {
        if(root != null){
            path += Integer.toString(root.val);
            if(root.left == null && root.right == null){
                paths.add(path);
            }else{
                path += "->";
                construct_paths(root.left, path, paths);
                construct_paths(root.right, path, paths);
            }
        }
    }

    public List<String> binaryTreePaths(TreeNode root) {
        LinkedList<String> paths = new LinkedList<String>();
        construct_paths(root, "", paths);
        return paths;
    }
    
}
```

