**题目来源**

[力扣（LeetCode）](https://leetcode-cn.com/)

[TOC]

# 简单(21-40)

## 1.[相同的树](https://leetcode-cn.com/problems/same-tree/)

**描述**

给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例**

示例1

```
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```

示例2

```
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```

示例3

```
输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```

**题解**

**Java**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    // 递归
    public boolean isSameTree(TreeNode p, TreeNode q) {
        // 都为空true
        if(p == null && q == null){
            return true;
        }
        // 只有一个为空, 返回false
        if(p == null || q == null){
            return false;
        }
        // 两边值不等, 返回false
        if(p.val != q.val){
            return false;
        }
        // 左右节点, 都进行递归
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

## 2.[对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

**描述**

给定一个二叉树，检查它是否是镜像对称的。

**示例**

示例1

```
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
```

示例2

```
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3
```

**题解**

**Java**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null){
            return true;
        }
        return isEqual(root.left, root.right);
    }
	// 递归
    public boolean isEqual(TreeNode left, TreeNode right){
        if(left == null && right == null){
            return true;
        }
        if(left == null || right == null){
            return false;
        }
        if(left.val != right.val){
            return false;
        }
        // 交叉对比
        return isEqual(left.left, right.right) && isEqual(left.right, right.left);
    }
}
```

## 3.[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

**描述**

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明** 

叶子节点是指没有子节点的节点。

**示例**

```
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
```

**题解**

**Java**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  // 递归, 比较左右两边的长度
  public int maxDepth(TreeNode root) {
    if(root == null){
        return 0;
    }else{
        int leftLength = maxDepth(root.left);
        int rigthLength = maxDepth(root.right);
        return (leftLength > rigthLength ? leftLength : rigthLength) + 1;
    }
  }
}
```

## 4.[二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

**描述**

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

**示例**

```
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
   
返回其自底向上的层次遍历为：
[
  [15,7],
  [9,20],
  [3]
]
```

**题解**

**Java**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> list = new ArrayList<>();
        if(root == null){
            return list;
        }
        // 使用队列, 将每个节点都存进队列中, 保证遍历的顺序
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            // 存储每一层的list
            List<Integer> tmp = new ArrayList<>();
            // 获取当前队列长度
            int len = queue.size();
            // 遍历, 将队列中全部节点取出, 再判断这些节点有没有left, right节点, 如果有再存入队列中
            // 这样保证, 每一次while循环, 队列中存的的节点都是同一层的节点
            for(int i=0; i<len; i++){
                TreeNode t = queue.poll();
                tmp.add(t.val);
                if(t.left != null){
                    queue.add(t.left);
                }
                if(t.right != null){
                    queue.add(t.right);
                }
            }
            // 将list插入到头部
            list.add(0, tmp);
        }
        return list;
    }
}
```

## 5.[将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

**描述**

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。

**示例**

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

**题解**

**Java**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return dg(0, nums.length-1, nums);
    }
	// 从中间向两边遍历
    public TreeNode dg(int left, int right, int[] nums){
        if(left > right) return null;
        int half = (left + right) / 2;
        TreeNode node = new TreeNode(nums[half]);
        node.left = dg(left, half-1, nums);
        node.right = dg(half+1, right, nums);
        return node;
    }
}
```

## 6.[平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

**描述**

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过1。

**示例**

示例1

```
给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。
```

示例2

```
给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
```

**题解**

**Java**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root == null) return true;
        return Math.abs(dg(root.left) - dg(root.right)) < 2 && isBalanced(root.left) && isBalanced(root.right);
    }

    public int dg(TreeNode root){
        int tmp = -1;
        if(root == null) return tmp;
        return 1 + Math.max(dg(root.left), dg(root.right));
    }
}
```

## 7.[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

**描述**

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明:** 叶子节点是指没有子节点的节点。

**示例**

给定二叉树 `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最小深度  2.

**题解**

**Java**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  public int minDepth(TreeNode root) {
    if(root == null) return 0;
    if(root.left == null && root.right == null) return 1;
    int depthCount = Integer.MAX_VALUE;
    if(root.left != null){
        depthCount = Math.min(minDepth(root.left), depthCount);
    }
    if(root.right != null){
        depthCount = Math.min(minDepth(root.right), depthCount);
    }
    return depthCount + 1;
  }
}
```

## 8.[路径总和](https://leetcode-cn.com/problems/path-sum/)

**描述**

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例**

给定如下二叉树，以及目标和 `sum = 22`，

```
			 5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```

返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。

**题解**

**Java**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    // 递归, 每次减掉当前节点得值, 当当前节点是叶子节点是, 判断sum是否等于0 
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null){
            return false;
        }
        sum -= root.val;
        if(root.left == null && root.right == null){
            return sum == 0;
        }
        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);
    }
}
```

## 9.[杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

**描述**

给定一个非负整数 *numRows，*生成杨辉三角的前 *numRows* 行。

**示例**

```
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

**题解**

**Java**

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> result = new ArrayList<>();
        for(int i=0; i<numRows; i++){
            List<Integer> list = new ArrayList<>();
            for(int j=0; j<=i; j++){
                // 当前数字是两边的数时, 直接赋值1
                if(j == 0 || j == i){
                    list.add(1);
                // 是中间的数时, 去上一行的两个数相加
                }else{
                    list.add(result.get(i-1).get(j-1) + result.get(i-1).get(j));
                }
            }
            result.add(list);
        }
        return result;
    }
}
```

## 10.[杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

**描述**

给定一个非负索引 *k*，其中 *k* ≤ 33，返回杨辉三角的第 *k* 行。

**示例**

```
输入: 3
输出: [1,3,3,1]
```

**题解**

**Java**

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> pre = new ArrayList<>();
        for(int i = 0; i <= rowIndex; i++){
            List<Integer> list = new ArrayList<>();
            for(int j = 0; j <= i; j++){
                if(j == 0 || j == i){
                    list.add(1);
                }else{
                    list.add(pre.get(j-1) + pre.get(j));
                }
            }
            pre = list;
        }
        return pre;
    }
}

class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> list = new ArrayList<>();
        for(int i = 0; i <= rowIndex; i++){
            for(int j = 0; j <= i; j++){
                if(j == 0){
                    list.add(1);
                }else if(j == i){
                    continue;
                }else{
                    list.set(i-j, list.get(i-j-1) + list.get(i-j));
                }
            }
        }
        return list;
    }
}
```

## 11.[买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**描述**

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

**示例**

示例一

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

示例二

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0
```

**题解**

**Java**

```java
class Solution {
    // 每次遍历, 比较当前节点是否是已遍历的最小节点, 替换最小节点
    // 比较当前节点的值 - 最小节点的值, 是否需要替换最大值
    // [10,2,3,8,1,9,0] 从2 ~ 8 存6, 之后,最小值替换为1, 只需考虑1之后的数减1, 是否大于6  
    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int max = 0;
        for(int i=0; i<prices.length; i++){
            if(prices[i] < min){
                min = prices[i];
            }else if(prices[i] - min > max){
                max = prices[i] - min;
            }
        }
        return max;
    }
}
```

## 12.[买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

**描述**

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例**

示例一

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

示例二

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

示例三

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**题解**

**Java**

```java
class Solution {
    // 比较连续两个节点, 后节点是否比前节点大, 如果大, 就加差值
    // 每次相加相当于累计收益,  当后节点比前节点小时, 跳过进入下一次循环, 相当于在当前节点卖出
    public int maxProfit(int[] prices) {
        int result = 0;
        for(int i=1; i<prices.length; i++){
            if(prices[i] > prices[i-1]){
                result += prices[i] - prices[i-1];
            }
        }
        return result;
    }
}
```

## 13.[验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

**描述**

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

**示例**

示例一

```
输入: "A man, a plan, a canal: Panama"
输出: true
```

示例二

```
输入: "race a car"
输出: false
```

**题解**

**Java**

```java
class Solution {
    // 双指针, 从两边遍历, 比较字符是否相同
    public boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        while(left < right){
            // Character.isLetterOrDigit判断字符是否为数字或者字母
            while(left < right && !Character.isLetterOrDigit(s.charAt(left))){
                left++;
            }
            while(left < right && !Character.isLetterOrDigit(s.charAt(right))){
                right--;
            }
            if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

## 14.[只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

**描述**

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例**

示例一

```
输入: [2,2,1]
输出: 1
```

示例二

```
输入: [4,1,2,1,2]
输出: 4
```

**题解**

**Java**

```java
class Solution {
    // 使用位运算, 异或, 异或满足交换律
    // 0 ^ 1 = 1
    // 0 ^ 0 = 0
    // 1 ^ 1 = 0
    // 所以[2,1,3,2,1]  0 ^ 2 ^ 1 ^ 3 ^ 2 ^ 1 = 0 ^ (1 ^ 1) ^ (2 ^ 2) ^ 3 = 0 ^ 0 ^ 0 ^ 3 = 3  
    public int singleNumber(int[] nums) {
        int tmp = 0;
        for(int i : nums){
            tmp ^= i;
        }
        return tmp;
    }
}
```

## 15.[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

**描述**

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

**示例**

示例一

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

示例二

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

示例三

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**题解**

**Java**

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    // 快慢指针, 快指针每次走两个节点, 慢指针每次走一个节点, 如果是环形链表, 快指针和慢指针一定会遇到
    // 如果不是环形链表, 快指针会先走到链表末尾, 判断快指针是否遍历到null, 为null就返回false
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null){
            return false;
        }
        ListNode fast = head.next;
        ListNode slow = head;
        while(fast != slow){
            if(fast == null || fast.next == null){
                return false;
            }
            fast = fast.next.next;
            slow = slow.next;
        }
        return true;
        
    }
}
```

## 16.[最小栈](https://leetcode-cn.com/problems/min-stack/)

**描述**

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

**示例**

示例一

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/min-stack
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**提示：**

- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用。

**题解**

**Java**

```java
class MinStack {

    private int top = -1;
    // 存每个值
    private List<Integer> list;
    // 存每次添加值时, 当前list的最小值
    private List<Integer> minList;

    /** initialize your data structure here. */
    public MinStack() {
        list = new ArrayList<>();
        minList = new ArrayList<>();
    }
    
    public void push(int x) {
        if(minList.size() == 0 || minList.get(top) > x){
            minList.add(x);
        }else{
            minList.add(minList.get(top));
        }
        top++;
        list.add(x);
    }
    
    public void pop() {
        if(top >= 0){
            minList.remove(top);
            list.remove(top);
            top--;
        }
        
    }
    
    public int top() {
        return list.get(top);
    }
    
    public int getMin() {
        return minList.get(top);
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

## 17.[相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

**描述**

编写一个程序，找到两个单链表相交的起始节点。

**示例**

示例一

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**注意：**

如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

**题解**

**Java**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    // 先遍历A和B, 如果A和B的长度相同, 并且在某个节点hA == hB 说明该节点是相交的节点, 如果没有相等的说明,遍历到最后, hA和hB会同时为null, 不相交
    // 如果A和B的长度不相同, 当A遍历结束hA指向B的头节点, 接着遍历, A+B的长度会等于B+A的长度
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
       if(headA == null || headB == null) return null;
       ListNode hA = headA;
       ListNode hB = headB;
       while(hA != hB){
           hA = hA == null ? headB : hA.next;
           hB = hB == null ? headA : hB.next;
       }
       return hA;
    }
}
```

## 18.[两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

**描述**

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

**说明:**

- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例**

示例一

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**题解**

**Java**

```java
class Solution {
    // 双指针, 指向两端, 不断向中间移动
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        while(left < right){
            int sum = numbers[left] + numbers[right];
            if(sum == target){
                int result[] = new int[2];
                result[0] = left+1;
                result[1] = right+1;
                return result;
            }else if(sum < target){
                left++;
            }else{
                right--;
            }
        }
        return null;
    }
}
```

## 19.[Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

**描述**

给定一个正整数，返回它在 Excel 表中相对应的列名称。

```
 1 -> A
 2 -> B
 3 -> C
 ...
 26 -> Z
 27 -> AA
 28 -> AB 
 ...
```

**示例**

示例一

```
输入: 1
输出: "A"
```

示例二

```
输入: 28
输出: "AB"
```

示例三

```
输入: 701
输出: "ZY"
```

**题解**

**Java**

```java
class Solution {
    public String convertToTitle(int n) {
        if(n <= 0){
            return "";
        }
        StringBuilder sb = new StringBuilder();
        // 转换为26进制, n-- 保证0-25 对应A-Z
        while(n > 0) {
            n--;
            sb.append((char)(n % 26 + 'A'));
            n /= 26;
        }
        return sb.reverse().toString();
    }
}
```

## 20.[多数元素](https://leetcode-cn.com/problems/majority-element/)

**描述**

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例**

示例一

```
输入: [3,2,3]
输出: 3
```

示例二

```
输入: [2,2,1,1,1,2,2]
输出: 2
```

**题解**

**Java**

```java
class Solution {
    // 使用排序, 众数总会是最中间的那个
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
}
```

## 