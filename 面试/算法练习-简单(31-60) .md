**题目来源**

[力扣（LeetCode）](https://leetcode-cn.com/)

[TOC]



# 简单(30-31)

## 1.[买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**描述**

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

**示例**

示例一

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

示例二

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0
```

**题解**

**Java**

```java
class Solution {
    // 每次遍历, 比较当前节点是否是已遍历的最小节点, 替换最小节点
    // 比较当前节点的值 - 最小节点的值, 是否需要替换最大值
    // [10,2,3,8,1,9,0] 从2 ~ 8 存6, 之后,最小值替换为1, 只需考虑1之后的数减1, 是否大于6  
    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int max = 0;
        for(int i=0; i<prices.length; i++){
            if(prices[i] < min){
                min = prices[i];
            }else if(prices[i] - min > max){
                max = prices[i] - min;
            }
        }
        return max;
    }
}
```

## 2.[买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

**描述**

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例**

示例一

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

示例二

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

示例三

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**题解**

**Java**

```java
class Solution {
    // 比较连续两个节点, 后节点是否比前节点大, 如果大, 就加差值
    // 每次相加相当于累计收益,  当后节点比前节点小时, 跳过进入下一次循环, 相当于在当前节点卖出
    public int maxProfit(int[] prices) {
        int result = 0;
        for(int i=1; i<prices.length; i++){
            if(prices[i] > prices[i-1]){
                result += prices[i] - prices[i-1];
            }
        }
        return result;
    }
}
```

## 3.[验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

**描述**

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

**示例**

示例一

```
输入: "A man, a plan, a canal: Panama"
输出: true
```

示例二

```
输入: "race a car"
输出: false
```

**题解**

**Java**

```java
class Solution {
    // 双指针, 从两边遍历, 比较字符是否相同
    public boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        while(left < right){
            // Character.isLetterOrDigit判断字符是否为数字或者字母
            while(left < right && !Character.isLetterOrDigit(s.charAt(left))){
                left++;
            }
            while(left < right && !Character.isLetterOrDigit(s.charAt(right))){
                right--;
            }
            if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

## 4.[只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

**描述**

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例**

示例一

```
输入: [2,2,1]
输出: 1
```

示例二

```
输入: [4,1,2,1,2]
输出: 4
```

**题解**

**Java**

```java
class Solution {
    // 使用位运算, 异或, 异或满足交换律
    // 0 ^ 1 = 1
    // 0 ^ 0 = 0
    // 1 ^ 1 = 0
    // 所以[2,1,3,2,1]  0 ^ 2 ^ 1 ^ 3 ^ 2 ^ 1 = 0 ^ (1 ^ 1) ^ (2 ^ 2) ^ 3 = 0 ^ 0 ^ 0 ^ 3 = 3  
    public int singleNumber(int[] nums) {
        int tmp = 0;
        for(int i : nums){
            tmp ^= i;
        }
        return tmp;
    }
}
```

## 5.[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

**描述**

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

**示例**

示例一

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

示例二

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

示例三

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**题解**

**Java**

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    // 快慢指针, 快指针每次走两个节点, 慢指针每次走一个节点, 如果是环形链表, 快指针和慢指针一定会遇到
    // 如果不是环形链表, 快指针会先走到链表末尾, 判断快指针是否遍历到null, 为null就返回false
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null){
            return false;
        }
        ListNode fast = head.next;
        ListNode slow = head;
        while(fast != slow){
            if(fast == null || fast.next == null){
                return false;
            }
            fast = fast.next.next;
            slow = slow.next;
        }
        return true;
        
    }
}
```

## 6.[最小栈](https://leetcode-cn.com/problems/min-stack/)

**描述**

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

**示例**

示例一

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/min-stack
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**提示：**

- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用。

**题解**

**Java**

```java
class MinStack {

    private int top = -1;
    // 存每个值
    private List<Integer> list;
    // 存每次添加值时, 当前list的最小值
    private List<Integer> minList;

    /** initialize your data structure here. */
    public MinStack() {
        list = new ArrayList<>();
        minList = new ArrayList<>();
    }
    
    public void push(int x) {
        if(minList.size() == 0 || minList.get(top) > x){
            minList.add(x);
        }else{
            minList.add(minList.get(top));
        }
        top++;
        list.add(x);
    }
    
    public void pop() {
        if(top >= 0){
            minList.remove(top);
            list.remove(top);
            top--;
        }
        
    }
    
    public int top() {
        return list.get(top);
    }
    
    public int getMin() {
        return minList.get(top);
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

## 7.[相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

**描述**

编写一个程序，找到两个单链表相交的起始节点。

**示例**

示例一

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**注意：**

如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

**题解**

**Java**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    // 先遍历A和B, 如果A和B的长度相同, 并且在某个节点hA == hB 说明该节点是相交的节点, 如果没有相等的说明,遍历到最后, hA和hB会同时为null, 不相交
    // 如果A和B的长度不相同, 当A遍历结束hA指向B的头节点, 接着遍历, A+B的长度会等于B+A的长度
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
       if(headA == null || headB == null) return null;
       ListNode hA = headA;
       ListNode hB = headB;
       while(hA != hB){
           hA = hA == null ? headB : hA.next;
           hB = hB == null ? headA : hB.next;
       }
       return hA;
    }
}
```

## 8.[两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

**描述**

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

**说明:**

- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例**

示例一

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**题解**

**Java**

```java
class Solution {
    // 双指针, 指向两端, 不断向中间移动
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        while(left < right){
            int sum = numbers[left] + numbers[right];
            if(sum == target){
                int result[] = new int[2];
                result[0] = left+1;
                result[1] = right+1;
                return result;
            }else if(sum < target){
                left++;
            }else{
                right--;
            }
        }
        return null;
    }
}
```

## 9.[Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

**描述**

给定一个正整数，返回它在 Excel 表中相对应的列名称。

```
 1 -> A
 2 -> B
 3 -> C
 ...
 26 -> Z
 27 -> AA
 28 -> AB 
 ...
```

**示例**

示例一

```
输入: 1
输出: "A"
```

示例二

```
输入: 28
输出: "AB"
```

示例三

```
输入: 701
输出: "ZY"
```

**题解**

**Java**

```java
class Solution {
    public String convertToTitle(int n) {
        if(n <= 0){
            return "";
        }
        StringBuilder sb = new StringBuilder();
        // 转换为26进制, n-- 保证0-25 对应A-Z
        while(n > 0) {
            n--;
            sb.append((char)(n % 26 + 'A'));
            n /= 26;
        }
        return sb.reverse().toString();
    }
}
```

## 10.[多数元素](https://leetcode-cn.com/problems/majority-element/)

**描述**

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例**

示例一

```
输入: [3,2,3]
输出: 3
```

示例二

```
输入: [2,2,1,1,1,2,2]
输出: 2
```

**题解**

**Java**

```java
class Solution {
    // 使用排序, 众数总会是最中间的那个
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
}
```

## 11.[Excel表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)

**描述**

给定一个Excel表格中的列名称，返回其相应的列序号。

例如，

    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...

**示例**

**示例 1:**

```
输入: "A"
输出: 1
```

**示例 2:**

```
输入: "AB"
输出: 28
```

**示例 3:**

```
输入: "ZY"
输出: 701
```

**题解**

**Java**

```java
class Solution {
    // 26进制转换为10进制
    public int titleToNumber(String s) {
        int res = 0;
        for(int i=0; i<s.length(); i++){
            int tmp = s.charAt(i) - 64;
            res = tmp + res * 26;
        }
        return res;
    }
}
```

## 12.[阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

**描述**

给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**示例**

示例 1:

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```


示例 2:

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

**说明**: 

你算法的时间复杂度应为 O(log n) 。

**题解**

**Java**

```java
class Solution {
    public int trailingZeroes(int n) {
        int zeroCount = 0;
        // 每有一个5, 就会多一个0
        while(n > 0){
            n /= 5;
            zeroCount += n;
        }
        return zeroCount;
    }
}
```

## 13.[旋转数组](https://leetcode-cn.com/problems/rotate-array/)

**描述**

给定一个数组，将数组中的元素向右移动 *k* 个位置，其中 *k* 是非负数。

**示例**

示例 1:

```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

示例 2:

```
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```

**说明**: 

- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 要求使用空间复杂度为 O(1) 的 **原地** 算法。

**题解**

**Java**

```java
// 环状替换
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;
        // 该count, 统计遍历的次数
        int count = 0;
        // k 有可能超出数组的长度, 造成无效循环, 所以取余
        k = k % len; 
        // nums : [1,2,3,4,5,6]   k : 2
        // 1->3 3->5 5->1 这样替换最终又会回到起点, 所以下方让cur=start, 当cur==start时, 结束do-while循环
        // start进行加一
        for(int start=0; count<len; start++){
            int cur = start;
            int current = nums[start];
            do{
                // 算出, 要被替换的点的位置
                int next = (cur+k) % len;
                // 取出, 被替换的数
                int tmp = nums[next];
                // 替换
                nums[next] = current;
                current = tmp;
                cur = next;
                count++;
            }while(cur != start);
        }
    }
}
// 翻转
class Solution {
    public void rotate(int[] nums, int k) {
        // nums = [1,2,3,4,5,6], k = 2
        k = k % nums.length;
        // 第一次翻转, 将数组全部翻转
        // nums = [6,5,4,3,2,1]
        reverse(nums, 0, nums.length-1);
        // 第二次, 将0-k翻转
        // nums = [5,6,4,3,2,1]
        reverse(nums, 0, k-1);
        // 第三次, 将后面的翻转
        // nums = [5,6,1,2,3,4]
        reverse(nums, k, nums.length-1); 
    }
    public void reverse(int[] nums, int start, int end) {
        while(start < end){
            int tmp = nums[start];
            nums[start] = nums[end];
            nums[end] = tmp;
            start++;
            end--;
        }
    }
}
```

## 14.[打家劫舍](https://leetcode-cn.com/problems/house-robber/)

**描述**

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例**

示例 1:

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

示例 2:

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**说明**: 

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

**题解**

**Java**

```java
class Solution {
    /*
    *  动态规划
    *  因为不能连续偷两家的钱, 所以偷n家的钱,最优解就是就是Max(nums[n-2] + nums[n], nums[n-1])中的最大值
    *  例子: n = 1 时, 最大值是nums[1]
    *       n = 2 时, 最大值是 max(nums[1], nums[2])
    *       n = 3 时, 最大值是 max(nums[3] + nums[3-2], nums[3-1])
    *       n = 4 时, 最大值是 max(nums[4] + nums[4-2], nums[4-1])
    *  每一次遍历, 都取之前的最优解,加上新值做比较
    */
    public int rob(int[] nums) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        if(nums.length == 1){
            return nums[0];
        }
        if(nums.length == 2){
            return Math.max(nums[0], nums[1]);
        }
        // first和seonde保存最近的两次最优解
        int first = nums[0];
        int second = Math.max(nums[0], nums[1]);
        for(int i=2; i<nums.length;i++){
            int tmp = second;
            second = Math.max(nums[i] + first, second);
            first = tmp;
        }
        return second;
    }
}
```

## 15.[快乐数](https://leetcode-cn.com/problems/happy-number/)

**描述**

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。

**示例**

```
输入：19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**题解**

**Java**

```java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> set = new HashSet<>();
        while(n != 1){
            // 判断该数字是否已遍历过, 已遍历过, 说明会无限循环, return false
            if(set.contains(n)){
                return false;
            }
            set.add(n);
            int tmp = n;
            n = 0;
            // 将数字每一位平方相加
            while(tmp != 0){
                int d = tmp % 10;
                n += d * d;
                tmp /= 10;
            }   
        }
        return true;
    }
}
```

## 16.[移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

**描述**

删除链表中等于给定值 **val** 的所有节点。

**示例**

```
输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
```

**题解**

**Java**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    // 哨兵模式
    public ListNode removeElements(ListNode head, int val) {
        // 定义一个前置节点
        ListNode sentinel = new ListNode(0);
        sentinel.next = head;
        // tmp指向前置节点
        ListNode tmp = node;
        while(head != null){
            // 当头节点的值为要删除的值, 让前置节点的下一个值, 为头节点的下一个值, 头节点指向下一个节点
            // 当头节点的值不为要删除的值, 前置节点指向头节点, 头节点指向下一个节点
            if(head.val == val){
                tmp.next = head.next;
            }else{
                tmp = head;
            }
            head = head.next;
        }
        return sentinel.next;
    }
}
```

## 17.[计数质数](https://leetcode-cn.com/problems/count-primes/)

**描述**

统计所有小于非负整数 *n* 的质数的数量。

**示例**

```
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

**题解**

**Java**

```java
class Solution {
    /* 
    * 排除法
    * 1. 排除掉大于2的偶数
    * 2. 从3开始, 排除掉3的奇数倍, 5的奇数倍, 6的奇数倍
    * 3. 这些数都排除后, 剩下的数量就是质数的数量
    */
    public int countPrimes(int n) {
        if(n <= 2){
            return 0;
        }
        int count = n / 2;
        boolean[] isPrimes = new boolean[n]; 
        // i*i<n 表示遍历sqrt(n)次就可全部排除
        // i=i+2 表示每次遍历奇数
        for(int i=3; i*i<n; i=i+2){
            if(isPrimes[i]){
                continue;
            }
            // j=j+i*2 表示每次遍历奇数的奇数倍
            for(int j=i*i; j<n; j=j+i*2){
                if(!isPrimes[j]){
                    count--;
                    isPrimes[j] = true;
                }
            }
        }
        return count;
    }
}
```

## 18.[同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)

**描述**

给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。

所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。

**示例**

**示例 1:**

```
输入: s = "egg", t = "add"
输出: true
```

**示例 2:**

```
输入: s = "foo", t = "bar"
输出: false
```

**示例 3:**

```
输入: s = "paper", t = "title"
输出: true
```

**说明:**

你可以假设 ***s*** 和 **t** 具有相同的长度。

**题解**

**Java**

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        return isSame(s, t) && isSame(t, s);
    }
	/*
	*  将映射存到map中, 每次遍历字符, 去查有没有已经存在的映射关系, 如果有, 这个映射的值是否与当前值相等
	*  如果没有映射, 新建映射关系
	*/
    public boolean isSame(String s, String t){
        Map<Character, Character> map = new HashMap<>();
        for(int i=0; i<s.length(); i++){
            if(map.containsKey(s.charAt(i))){
                if(map.get(s.charAt(i)) != t.charAt(i)){
                    return false;
                }
            }else{
                map.put(s.charAt(i), t.charAt(i));
            }
        }
        return true;
    }
}
```

## 19.[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

**描述**

反转一个单链表。

**示例**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**进阶:**

你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

**题解**

**Java**

```java
class Solution {
    // 循环
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        while(head != null){
            ListNode node = head.next;
            head.next = pre;
            pre = head;
            head = node;
        }
        return pre;
    }
	// 递归
    public ListNode reverseList2(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode p = reverseList(head.next);
        // 让相邻两个节点, 翻转
        head.next.next = head;
        head.next = null;
        return p;
    }
}
```

## 20.[存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

**描述**

给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

**示例**

**示例 1:**

```
输入: [1,2,3,1]
输出: true
```

**示例 2:**

```
输入: [1,2,3,4]
输出: false
```

**示例 3:**

```
输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
```

**题解**

**Java**

```java
class Solution {
    // 先排序, 然后比较前后两个值
    public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums);
        for (int i = 0; i < nums.length - 1; ++i) {
            if (nums[i] == nums[i + 1]) return true;
        }
        return false;
    }
}
```

## 21.[存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

**描述**

给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。

**示例**

**示例 1:**

```
输入: nums = [1,2,3,1], k = 3
输出: true
```

**示例 2:**

```
输入: nums = [1,0,1,1], k = 1
输出: true
```

**示例 3:**

```
输入: nums = [1,2,3,1,2,3], k = 2
输出: false
```

**题解**

**Java**

```java
class Solution {
    // 将值和索引存储到map中,  判断相同得, 取出索引比较差值
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        int i=0;
        for(int num: nums){
            if(map.containsKey(num)){
                if(Math.abs(map.get(num) - i) <= k){
                    return true;
                }
            }
            map.put(num, i);     
            i++;
        }
        return false;
    }
}
```

## 22.[用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

使用队列实现栈的下列操作：

push(x) -- 元素 x 入栈
pop() -- 移除栈顶元素
top() -- 获取栈顶元素
empty() -- 返回栈是否为空
注意:

你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。
你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

**题解**

**Java**

```java
class MyStack {

    private Queue<Integer> q = new LinkedList<>();
    private int top;
    /** Initialize your data structure here. */
    public MyStack() {
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        // 每次新加元素, 颠倒顺序
        q.add(x);
        int size = q.size();
        while(size > 1){
            q.add(q.remove());
            size--;
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return q.remove();
    }
    
    /** Get the top element. */
    public int top() {
        return q.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return q.isEmpty();
    }
}
```

