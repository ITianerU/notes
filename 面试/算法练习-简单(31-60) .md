**题目来源**

[力扣（LeetCode）](https://leetcode-cn.com/)

# 简单(30-31)

## 1.[买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**描述**

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

**示例**

示例一

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

示例二

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0
```

**题解**

**Java**

```java
class Solution {
    // 每次遍历, 比较当前节点是否是已遍历的最小节点, 替换最小节点
    // 比较当前节点的值 - 最小节点的值, 是否需要替换最大值
    // [10,2,3,8,1,9,0] 从2 ~ 8 存6, 之后,最小值替换为1, 只需考虑1之后的数减1, 是否大于6  
    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int max = 0;
        for(int i=0; i<prices.length; i++){
            if(prices[i] < min){
                min = prices[i];
            }else if(prices[i] - min > max){
                max = prices[i] - min;
            }
        }
        return max;
    }
}
```

## 2.[买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

**描述**

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例**

示例一

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

示例二

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

示例三

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**题解**

**Java**

```java
class Solution {
    // 比较连续两个节点, 后节点是否比前节点大, 如果大, 就加差值
    // 每次相加相当于累计收益,  当后节点比前节点小时, 跳过进入下一次循环, 相当于在当前节点卖出
    public int maxProfit(int[] prices) {
        int result = 0;
        for(int i=1; i<prices.length; i++){
            if(prices[i] > prices[i-1]){
                result += prices[i] - prices[i-1];
            }
        }
        return result;
    }
}
```

## 3.[验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

**描述**

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

**示例**

示例一

```
输入: "A man, a plan, a canal: Panama"
输出: true
```

示例二

```
输入: "race a car"
输出: false
```

**题解**

**Java**

```java
class Solution {
    // 双指针, 从两边遍历, 比较字符是否相同
    public boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        while(left < right){
            // Character.isLetterOrDigit判断字符是否为数字或者字母
            while(left < right && !Character.isLetterOrDigit(s.charAt(left))){
                left++;
            }
            while(left < right && !Character.isLetterOrDigit(s.charAt(right))){
                right--;
            }
            if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

## 4.[只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

**描述**

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例**

示例一

```
输入: [2,2,1]
输出: 1
```

示例二

```
输入: [4,1,2,1,2]
输出: 4
```

**题解**

**Java**

```java
class Solution {
    // 使用位运算, 异或, 异或满足交换律
    // 0 ^ 1 = 1
    // 0 ^ 0 = 0
    // 1 ^ 1 = 0
    // 所以[2,1,3,2,1]  0 ^ 2 ^ 1 ^ 3 ^ 2 ^ 1 = 0 ^ (1 ^ 1) ^ (2 ^ 2) ^ 3 = 0 ^ 0 ^ 0 ^ 3 = 3  
    public int singleNumber(int[] nums) {
        int tmp = 0;
        for(int i : nums){
            tmp ^= i;
        }
        return tmp;
    }
}
```

## 5.[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

**描述**

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

**示例**

示例一

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

示例二

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

示例三

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**题解**

**Java**

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    // 快慢指针, 快指针每次走两个节点, 慢指针每次走一个节点, 如果是环形链表, 快指针和慢指针一定会遇到
    // 如果不是环形链表, 快指针会先走到链表末尾, 判断快指针是否遍历到null, 为null就返回false
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null){
            return false;
        }
        ListNode fast = head.next;
        ListNode slow = head;
        while(fast != slow){
            if(fast == null || fast.next == null){
                return false;
            }
            fast = fast.next.next;
            slow = slow.next;
        }
        return true;
        
    }
}
```

## 6.[最小栈](https://leetcode-cn.com/problems/min-stack/)

**描述**

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

**示例**

示例一

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/min-stack
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**提示：**

- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用。

**题解**

**Java**

```java
class MinStack {

    private int top = -1;
    // 存每个值
    private List<Integer> list;
    // 存每次添加值时, 当前list的最小值
    private List<Integer> minList;

    /** initialize your data structure here. */
    public MinStack() {
        list = new ArrayList<>();
        minList = new ArrayList<>();
    }
    
    public void push(int x) {
        if(minList.size() == 0 || minList.get(top) > x){
            minList.add(x);
        }else{
            minList.add(minList.get(top));
        }
        top++;
        list.add(x);
    }
    
    public void pop() {
        if(top >= 0){
            minList.remove(top);
            list.remove(top);
            top--;
        }
        
    }
    
    public int top() {
        return list.get(top);
    }
    
    public int getMin() {
        return minList.get(top);
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

## 7.[相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

**描述**

编写一个程序，找到两个单链表相交的起始节点。

**示例**

示例一

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**注意：**

如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

**题解**

**Java**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    // 先遍历A和B, 如果A和B的长度相同, 并且在某个节点hA == hB 说明该节点是相交的节点, 如果没有相等的说明,遍历到最后, hA和hB会同时为null, 不相交
    // 如果A和B的长度不相同, 当A遍历结束hA指向B的头节点, 接着遍历, A+B的长度会等于B+A的长度
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
       if(headA == null || headB == null) return null;
       ListNode hA = headA;
       ListNode hB = headB;
       while(hA != hB){
           hA = hA == null ? headB : hA.next;
           hB = hB == null ? headA : hB.next;
       }
       return hA;
    }
}
```

## 8.[两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

**描述**

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

**说明:**

- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例**

示例一

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**题解**

**Java**

```java
class Solution {
    // 双指针, 指向两端, 不断向中间移动
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        while(left < right){
            int sum = numbers[left] + numbers[right];
            if(sum == target){
                int result[] = new int[2];
                result[0] = left+1;
                result[1] = right+1;
                return result;
            }else if(sum < target){
                left++;
            }else{
                right--;
            }
        }
        return null;
    }
}
```

## 9.[Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

**描述**

给定一个正整数，返回它在 Excel 表中相对应的列名称。

```
 1 -> A
 2 -> B
 3 -> C
 ...
 26 -> Z
 27 -> AA
 28 -> AB 
 ...
```

**示例**

示例一

```
输入: 1
输出: "A"
```

示例二

```
输入: 28
输出: "AB"
```

示例三

```
输入: 701
输出: "ZY"
```

**题解**

**Java**

```java
class Solution {
    public String convertToTitle(int n) {
        if(n <= 0){
            return "";
        }
        StringBuilder sb = new StringBuilder();
        // 转换为26进制, n-- 保证0-25 对应A-Z
        while(n > 0) {
            n--;
            sb.append((char)(n % 26 + 'A'));
            n /= 26;
        }
        return sb.reverse().toString();
    }
}
```

## 10.[多数元素](https://leetcode-cn.com/problems/majority-element/)

**描述**

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例**

示例一

```
输入: [3,2,3]
输出: 3
```

示例二

```
输入: [2,2,1,1,1,2,2]
输出: 2
```

**题解**

**Java**

```java
class Solution {
    // 使用排序, 众数总会是最中间的那个
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
}
```

## 11.[Excel表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)

**描述**

给定一个Excel表格中的列名称，返回其相应的列序号。

例如，

    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...

**示例**

**示例 1:**

```
输入: "A"
输出: 1
```

**示例 2:**

```
输入: "AB"
输出: 28
```

**示例 3:**

```
输入: "ZY"
输出: 701
```

**题解**

**Java**

```java
class Solution {
    // 26进制转换为10进制
    public int titleToNumber(String s) {
        int res = 0;
        for(int i=0; i<s.length(); i++){
            int tmp = s.charAt(i) - 64;
            res = tmp + res * 26;
        }
        return res;
    }
}
```

## 13.[阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

**描述**

给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**示例**

示例 1:

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```


示例 2:

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

**说明**: 

你算法的时间复杂度应为 O(log n) 。

**题解**

**Java**

```java
class Solution {
    public int trailingZeroes(int n) {
        int zeroCount = 0;
        // 每有一个5, 就会多一个0
        while(n > 0){
            n /= 5;
            zeroCount += n;
        }
        return zeroCount;
    }
}
```

## 12.[旋转数组](https://leetcode-cn.com/problems/rotate-array/)

**描述**

给定一个数组，将数组中的元素向右移动 *k* 个位置，其中 *k* 是非负数。

**示例**

示例 1:

```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

示例 2:

```
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```

**说明**: 

- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 要求使用空间复杂度为 O(1) 的 **原地** 算法。

**题解**

**Java**

```java
// 环状替换
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;
        // 该count, 统计遍历的次数
        int count = 0;
        // k 有可能超出数组的长度, 造成无效循环, 所以取余
        k = k % len; 
        // nums : [1,2,3,4,5,6]   k : 2
        // 1->3 3->5 5->1 这样替换最终又会回到起点, 所以下方让cur=start, 当cur==start时, 结束do-while循环
        // start进行加一
        for(int start=0; count<len; start++){
            int cur = start;
            int current = nums[start];
            do{
                // 算出, 要被替换的点的位置
                int next = (cur+k) % len;
                // 取出, 被替换的数
                int tmp = nums[next];
                // 替换
                nums[next] = current;
                current = tmp;
                cur = next;
                count++;
            }while(cur != start);
        }
    }
}
// 翻转
class Solution {
    public void rotate(int[] nums, int k) {
        // nums = [1,2,3,4,5,6], k = 2
        k = k % nums.length;
        // 第一次翻转, 将数组全部翻转
        // nums = [6,5,4,3,2,1]
        reverse(nums, 0, nums.length-1);
        // 第二次, 将0-k翻转
        // nums = [5,6,4,3,2,1]
        reverse(nums, 0, k-1);
        // 第三次, 将后面的翻转
        // nums = [5,6,1,2,3,4]
        reverse(nums, k, nums.length-1); 
    }
    public void reverse(int[] nums, int start, int end) {
        while(start < end){
            int tmp = nums[start];
            nums[start] = nums[end];
            nums[end] = tmp;
            start++;
            end--;
        }
    }
}
```