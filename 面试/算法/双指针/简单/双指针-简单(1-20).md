**题目来源**

[力扣（LeetCode）](https://leetcode-cn.com/)

[TOC]



# 双指针-简单(1-20)

## 1.[[26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)]

**描述**

给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

**示例**

**示例 1：**

```
给定数组 nums = [1,1,2], 
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
你不需要考虑数组中超出新长度后面的元素。
```

**示例 2:**

```
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
```

**题解**

**Java**

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int slow = 0;
        for(int fast=1; fast<nums.length; fast++){
            if(nums[slow] != nums[fast]){
                slow++;
                nums[slow] = nums[fast];
            }
        }
        return slow+1;
    }
}
```

## 2.[[27. 移除元素](https://leetcode-cn.com/problems/remove-element/)]

**描述**

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**示例**

**示例 1：**

```
给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
```

**示例 2:**

```
给定 nums = [0,1,2,2,3,0,4,2], val = 2,
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。
你不需要考虑数组中超出新长度后面的元素。
```

**题解**

**Java**

```java
class Solution {
    public int removeElement(int[] nums, int val) {
       int slow = 0;
       for(int fast=0; fast<nums.length; fast++){
           if(nums[fast] != val){
               nums[slow] = nums[fast];
               slow++;
           }
       }
       return slow;
    }
}
```

## 3.[[167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)]

**描述**

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

**说明:**

- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例**

**示例 1：**

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**题解**

**Java**

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        int[] result = new int[2];
        while(left < right){
            int sum = numbers[left] + numbers[right];
            if(sum == target){
                result[0] = left+1;
                result[1] = right+1;
                return result;
            }else if(sum < target){
                left++;
            }else{
                right--;
            }
        }
        return result;
    }
}
```

## 4.[[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)]

**描述**

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例**

**示例 1：**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

**题解**

**Java**

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0;
        for(int fast=0; fast<nums.length; fast++){
            if(nums[fast] != 0){
                nums[slow] = nums[fast];
                // 当两个指针不指向同一个节点时, 才置为0
                if(fast != slow){
                    nums[fast] = 0;
                }
                slow++;
            }
        }
    }
}
```

## 5.[[344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)]

**描述**

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

**示例**

**示例 1：**

```
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

**示例 2：**

```
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

**题解**

**Java**

```java
class Solution {
    public void reverseString(char[] s) {
        int left = 0;
        int right = s.length-1;
        while(left < right){
            char tmp = s[left];
            s[left] = s[right];
            s[right] = tmp;
            left++;
            right--;
        }
    }
}
```

