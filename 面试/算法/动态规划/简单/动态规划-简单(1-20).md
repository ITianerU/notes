**题目来源**

[力扣（LeetCode）](https://leetcode-cn.com/)

[TOC]



# 动态规划-简单(1-20)

## 1.[[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)]

**描述**

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例**

**示例 1：**

```
输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6
```

**题解**

**Java**

```java
class Solution {
    // 只有当上一步的结果, 大于0, 才加上上一步的结果, 这样算出每一步的最优解
    public int maxSubArray(int[] nums) {
        int max = nums[0];
        for(int i=1; i<nums.length; i++){
            if(nums[i-1] > 0){
                nums[i] += nums[i-1];
            }
            if(max < nums[i]){
                max = nums[i];
            }
        }
        return max;
    }
}
```

## 2.[[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)]

**描述**

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数

**示例**

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

**题解**

**Java*

```java
class Solution {
    // 当n=1时, 只有一种方法
    // 当n=2时, 可以一下迈两步, 或者迈两下一步,  有两种方法
    // 当n=3时, 可以在n=1的基础上, 再迈两步, 也可以再n=2的基础上再迈一步, n=1有一种方法, n=2有两种方法 
    // 所以1 + 2 =3种方法
    // 当n=4时, 可以再n=2的基础上, 再迈两步, 也可以在n=3的基础上再迈一步, n=2有两种方法, n=3有3种方法
    // 所以2 + 3 = 5种
    public int climbStairs(int n) {
        if(n == 1) return 1;
        int p = 1;
        int q = 2;
        for(int i=2; i<n; i++){
            int t = p + q;
            p = q;
            q = t;
        }
        return q;
    }
}
```

## 3.[[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)]

**描述**

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

**示例**

**示例 1：**

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**题解**

**Java**

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length == 0) return 0;
        // 历史最低价格
        int minPrice = prices[0];
        int ans = 0;
        for(int i=1; i<prices.length; i++){
            // 更改历史最低价格
            if(prices[i] < minPrice){
                minPrice = prices[i];
            }else{
                // 算出在当前价格下卖出, 所获得的利润
                ans = Math.max(prices[i] - minPrice, ans);
            }
        }
        return ans;
    }
}
```

## 4.[[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)]

**描述**

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例**

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

**题解**

**Java**

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        // 记录i-2次的最优解
        int first = nums[0];
        // 记录i-1次的最优解
        int second = Math.max(nums[1], nums[0]);
        for(int i=2; i<nums.length; i++){
            int tmp = second;
            // 如果当前的钱 加上 i-2次的最优解, 大于i-1次的最优解. 记录当前的钱 加上 i-2次的最优解
            // 反之, i-1的最优解不变
            if(nums[i] + first > second){
                second = nums[i] + first;  
            }
            first = tmp;
        }
        return second;
    }
}
```

## 5.[[276.栅栏涂色](https://leetcode-cn.com/problems/paint-fence)]

## 6.[[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)]

**描述**

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例**

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

**题解**

**Java**

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        // 记录i-2次的最优解
        int first = nums[0];
        // 记录i-1次的最优解
        int second = Math.max(nums[1], nums[0]);
        for(int i=2; i<nums.length; i++){
            int tmp = second;
            // 如果当前的钱 加上 i-2次的最优解, 大于i-1次的最优解. 记录当前的钱 加上 i-2次的最优解
            // 反之, i-1的最优解不变
            if(nums[i] + first > second){
                second = nums[i] + first;  
            }
            first = tmp;
        }
        return second;
    }
}
```

## 