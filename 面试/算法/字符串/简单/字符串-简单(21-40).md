**题目来源**

[力扣（LeetCode）](https://leetcode-cn.com/)

[TOC]



# 字符串-简单(1-20)

## 1.[[606. 根据二叉树创建字符串](https://leetcode-cn.com/problems/construct-string-from-binary-tree/)]

**描述**

你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。

空节点则用一对空括号 "()" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。

**示例**

**示例 1：**

```
输入: 二叉树: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     
输出: "1(2(4))(3)"
解释: 原本将是“1(2(4)())(3())”，
在你省略所有不必要的空括号对之后，
它将是“1(2(4))(3)”。
```

**示例 2：**

```
输入: 二叉树: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 
输出: "1(2()(4))(3)"
解释: 和第一个示例相似，
除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。
```

**题解**

**Java**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public String tree2str(TreeNode t) {
        if(t == null) return "";
        StringBuilder sb = new StringBuilder();
        sb.append(t.val);
        dg(t.left, t.right, sb);
        return sb.toString();
    }
	// 递归
    public void dg(TreeNode leftNode, TreeNode rightNode, StringBuilder sb){
        if(leftNode == null && rightNode == null) return;
        // 左节点不为空, 
        if(leftNode != null){
            sb.append("(").append(leftNode.val);
            dg(leftNode.left, leftNode.right, sb);
            sb.append(")");
        }
        if(leftNode == null && rightNode != null){
            sb.append("()");
        }
        if(rightNode != null){
            sb.append("(").append(rightNode.val);
            dg(rightNode.left, rightNode.right, sb);
            sb.append(")");
        }
    }
}
```

## 2.[[657. 机器人能否返回原点](https://leetcode-cn.com/problems/robot-return-to-origin/)]

**描述**

在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。

移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。

注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。

**示例**

**示例 1：**

```
输入: "UD"
输出: true
解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。
```

**示例 2：**

```
输入: "LL"
输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。
```

**题解**

**Java**

```java
class Solution {
    public boolean judgeCircle(String moves) {
        int posLR = 0;
        int posUD = 0;
        char[] chars = moves.toCharArray();
        for(char c : chars){
            if(c == 'U'){
                posUD++;
            }else if(c == 'D'){
                posUD--;
            }else if(c == 'R'){
                posLR++;
            }else{
                posLR--;
            }
        }
        return posLR == 0 && posUD == 0;
    }
}
```

