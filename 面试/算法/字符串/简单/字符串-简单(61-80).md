**题目来源**

[力扣（LeetCode）](https://leetcode-cn.com/)

[TOC]



# 字符串-简单(61-80)

## 41.[[1496. 判断路径是否相交](https://leetcode-cn.com/problems/path-crossing/)]

**描述**

给你一个字符串 path，其中 path[i] 的值可以是 'N'、'S'、'E' 或者 'W'，分别表示向北、向南、向东、向西移动一个单位。

机器人从二维平面上的原点 (0, 0) 处开始出发，按 path 所指示的路径行走。

如果路径在任何位置上出现相交的情况，也就是走到之前已经走过的位置，请返回 True ；否则，返回 False 。

**示例**

**示例 1：**

```
输入：path = "NES"
输出：false 
解释：该路径没有在任何位置相交。
```

**示例 2：**

```
输入：path = "NESWW"
输出：true
解释：该路径经过原点两次。
```

**提示：**

1. `1 <= path.length <= 10^4`
2. `path` 仅由 `{'N', 'S', 'E', 'W}` 中的字符组成

**题解**

**Java**

```java
class Solution {
    // 存放到set中, 查找是否有重复的
    public boolean isPathCrossing(String path) {
        char[] pos = new char[2];
        pos[0] = '0';
        pos[1] = '0';
        Set<String> set = new HashSet();
        set.add(new String(pos));
        for(char c : path.toCharArray()){
            if(c == 'N'){
                pos[1]++;
            }else if(c == 'S'){
                pos[1]--;
            }else if(c == 'E'){
                pos[0]++;
            }else{
                pos[0]--;
            }
            String tmp = new String(pos);
            if(set.contains(tmp)){
                return true;
            }else{
                set.add(tmp);
            }
        }
        return false;
    }
}
```

## 42.[[1507. 转变日期格式](https://leetcode-cn.com/problems/reformat-date/)]

**描述**

给你一个字符串 date ，它的格式为 Day Month Year ，其中：

- Day 是集合 {"1st", "2nd", "3rd", "4th", ..., "30th", "31st"} 中的一个元素。
- Month 是集合 {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"} 中的一个元素。
- Year 的范围在 [1900, 2100] 之间。

请你将字符串转变为 YYYY-MM-DD 的格式，其中：

- YYYY 表示 4 位的年份。
- MM 表示 2 位的月份。
- DD 表示 2 位的天数。

**示例**

**示例 1：**

```
输入：date = "20th Oct 2052"
输出："2052-10-20"
```

**示例 2：**

```
输入：date = "6th Jun 1933"
输出："1933-06-06"
```

**示例 3：**

```
输入：date = "26th May 1960"
输出："1960-05-26"
```

**提示：**

1. 给定日期保证是合法的，所以不需要处理异常输入。

**题解**

**Java**

```java
class Solution {
    public String reformatDate(String date) {
        String[] months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
        Map<String, Integer> s2month = new HashMap<String, Integer>();
        for (int i = 1; i <= 12; i++) {
            s2month.put(months[i - 1], i);
        }
        String[] array = date.split(" ");
        int year = Integer.parseInt(array[2]);
        int month = s2month.get(array[1]);
        int day = Integer.parseInt(array[0].substring(0, array[0].length() - 2));
        return String.format("%d-%02d-%02d", year, month, day);
    }
}
```

## 43.[[1544. 整理字符串](https://leetcode-cn.com/problems/make-the-string-great/)]

**描述**

给你一个由大小写英文字母组成的字符串 s 。

一个整理好的字符串中，两个相邻字符 s[i] 和 s[i+1]，其中 0<= i <= s.length-2 ，要满足如下条件:

- 若 s[i] 是小写字符，则 s[i+1] 不可以是相同的大写字符。
- 若 s[i] 是大写字符，则 s[i+1] 不可以是相同的小写字符。

请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。

请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。

注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。

**示例**

**示例 1：**

```
输入：s = "leEeetcode"
输出："leetcode"
解释：无论你第一次选的是 i = 1 还是 i = 2，都会使 "leEeetcode" 缩减为 "leetcode" 。
```

**示例 2：**

```
输入：s = "abBAcC"
输出：""
解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：
"abBAcC" --> "aAcC" --> "cC" --> ""
"abBAcC" --> "abBA" --> "aA" --> ""
```

**示例 3：**

```
输入：s = "s"
输出："s"
```

**提示：**

1. `1 <= s.length <= 100`
2. `s` 只包含小写和大写英文字母

**题解**

**Java**

```java
class Solution {
    public String makeGood(String s) {
        char[] chars = s.toCharArray();
        StringBuilder sb = new StringBuilder();
        // i的索引指向StringBuilder
        int i = -1;
        for(char c : chars){
            // 相同就删除sb中最后的字符
            if(sb.length() > 0 && (c - sb.charAt(i) == 32 || c - sb.charAt(i) == -32)){
                sb.deleteCharAt(i);
                i--;
               // 不相同, 添加到sb中
            }else{
                sb.append(c);
                i++;
            }
        }
        return sb.toString();
    }
}
```

## 44.[[1556. 千位分隔数](https://leetcode-cn.com/problems/thousand-separator/)]

**描述**

给你一个整数 `n`，请你每隔三位添加点（即 "." 符号）作为千位分隔符，并将结果以字符串格式返回

**示例**

**示例 1：**

```
输入：n = 987
输出："987"
```

**示例 2：**

```
输入：n = 1234
输出："1.234"
```

**示例 3：**

```
输入：n = 123456789
输出："123.456.789"
```

**提示：**

1. `0 <= n < 2^31`

**题解**

**Java**

```java
class Solution {
    // 每三位补0
    public String thousandSeparator(int n) {
        StringBuilder sb = new StringBuilder();
        if(n == 0) return "0";
        int i = 0;
        while(n != 0){
            if(i !=0 && i % 3 == 0){
                sb.append(".");
            }
            sb.append(n % 10);
            n /= 10;
            i++;
        }
        return sb.reverse().toString();
    }
}
```

## 45.[[1576. 替换所有的问号](https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/)]

**描述**

给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。

注意：你 不能 修改非 '?' 字符。

题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。

在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。

**示例**

**示例 1：**

```
输入：s = "?zs"
输出："azs"
解释：该示例共有 25 种解决方案，从 "azs" 到 "yzs" 都是符合题目要求的。只有 "z" 是无效的修改，因为字符串 "zzs" 中有连续重复的两个 'z' 。
```

**示例 2：**

```
输入：s = "ubv?w"
输出："ubvaw"
解释：该示例共有 24 种解决方案，只有替换成 "v" 和 "w" 不符合题目要求。因为 "ubvvw" 和 "ubvww" 都包含连续重复的字符。
```

**示例 3：**

```
输入：s = "j?qg??b"
输出："jaqgacb"
```

**提示：**

1. `1 <= s.length <= 100`
2. `s` 仅包含小写英文字母和 `'?'` 字符

**题解**

**Java**

```java
class Solution {
    public String modifyString(String s) {
        if(s.length() == 1) return "a";
        char[] chars = s.toCharArray();
        for(int i=0; i<chars.length; i++){
            if(chars[i] == '?'){
                char tmp = 'a';
                // 取出前面的字符
                char pre = i != chars.length - 1 ? chars[i+1] : ' ';
                // 取出后面的字符
                char next = i != 0 ? chars[i-1] : ' ';
                // 判断, 有一个相等就+1;
                while(tmp == pre || tmp == next){
                    tmp += 1;
                }
                chars[i] = tmp;
            }
        }
        return new String(chars);
    }
}
```

## 46.[[1576. 替换所有的问号](https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/)]

**描述**

给你一个字符串 text ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 text 至少包含一个单词 。

请你重新排列空格，使每对相邻单词之间的空格数目都 相等 ，并尽可能 最大化 该数目。如果不能重新平均分配所有空格，请 将多余的空格放置在字符串末尾 ，这也意味着返回的字符串应当与原 text 字符串的长度相等。

返回 重新排列空格后的字符串 。

**示例**

**示例 1：**

```
输入：text = "  this   is  a sentence "
输出："this   is   a   sentence"
解释：总共有 9 个空格和 4 个单词。可以将 9 个空格平均分配到相邻单词之间，相邻单词间空格数为：9 / (4-1) = 3 个。
```

**示例 2：**

```
输入：text = " practice   makes   perfect"
输出："practice   makes   perfect "
解释：总共有 7 个空格和 3 个单词。7 / (3-1) = 3 个空格加上 1 个多余的空格。多余的空格需要放在字符串的末尾。
```

**示例 3：**

```
输入：text = "hello   world"
输出："hello   world"
```

**提示：**

1. `1 <= text.length <= 100`
2. `text` 由小写英文字母和 `' '` 组成
3. `text` 中至少包含一个单词

**题解**

**Java**

```java
class Solution {
    public String reorderSpaces(String text) {
        // 空格数量
        int spaceCount = 0;
        // 单词数量, -1为单词的间隔数量
        int wordCount = 0;
        // 填充到末尾的空格数量
        int num = 0;
        StringBuilder sb = new StringBuilder();
        // 大空格
        StringBuilder space = new StringBuilder();
        char[] chars = text.toCharArray();
        for(int i=0; i<chars.length; i++){
            // 计算空格数量
            if(chars[i] == ' '){
                spaceCount++;
                // 计算单词数量
            }else if(i == chars.length-1 || chars[i+1] == ' '){
                wordCount++;
            }
        }
        // 单词数量-1, 为两个单词之间的间隔数量
        wordCount--;
        // 间距为0, 空格全部填充到末尾
        if(wordCount == 0){
            num = spaceCount;
        }else{
            // 计算每个间距要填充的空格数量
            int avg = spaceCount / (wordCount);
            // 计算末尾空格的数量
            num = spaceCount % (wordCount);
            // 造出大空格
            for(int i=0; i<avg; i++){
                space.append(' ');
            }
        }
        for(int i=0; i<chars.length; i++){
            if(chars[i] != ' '){
                sb.append(chars[i]);
                // 往单词间隔之间, 填充大空格
                if(wordCount !=0 && chars[i+1] == ' '){
                    sb.append(space);
                    wordCount--;
                }
            }
        }
        // 往末尾填充空格
        for(int i=0; i<num; i++){
            sb.append(' ');
        }
        return sb.toString();
    }
}
```

## 