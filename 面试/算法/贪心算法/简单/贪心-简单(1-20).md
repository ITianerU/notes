**题目来源**

[力扣（LeetCode）](https://leetcode-cn.com/)

[TOC]



# 栈-简单(1-20)

## 1.[[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)]

**描述**

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例**

**示例 1：**

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2：**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 2：**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

- `1 <= prices.length <= 3 * 10 ^ 4`
- `0 <= prices[i] <= 10 ^ 4`

**题解**

**Java**

```java
class Solution {
    public int maxProfit(int[] prices) {
        int sum = 0;
        for(int i=1; i<prices.length; i++){
            sum += Math.max(0, prices[i] - prices[i-1]);
        }
        return sum;
    }
}
```

## 2.[[392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)]

**描述**

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

**示例**

**示例 1：**

```
输入：s = "abc", t = "ahbgdc"
输出：true
```

**示例 2：**

```
输入：s = "axc", t = "ahbgdc"
输出：false
```

**提示：**

- `0 <= s.length <= 100`
- `0 <= t.length <= 10^4`
- 两个字符串都只由小写字符组成。

**题解**

**Java**

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        char[] schars = s.toCharArray();
        char[] tchars = t.toCharArray();
        int si = 0, ti = 0;
        while(si < schars.length && ti < tchars.length){
            if(schars[si] == tchars[ti]){
                si++;
            }
            ti++;
        }
        return si == schars.length;
    }
}
```

## 3.[[455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)]

**描述**

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**示例**

**示例 1：**

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

**示例 2：**

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

**提示：**

- `1 <= g.length <= 3 * 104`
- `0 <= s.length <= 3 * 104`
- `1 <= g[i], s[j] <= 231 - 1`

**题解**

**Java**

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int gi = 0, si = 0;
        while(gi < g.length && si < s.length){
            if(g[gi] <= s[si]){
                gi++;    
            }
            si++;
        }
        return gi;
    }
}
```

## 4.[[605. 种花问题](https://leetcode-cn.com/problems/can-place-flowers/)]

**描述**

假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。

**示例**

**示例 1：**

```
输入: flowerbed = [1,0,0,0,1], n = 1
输出: True
```

**示例 2：**

```
输入: flowerbed = [1,0,0,0,1], n = 2
输出: False
```

**提示：**

- 数组内已种好的花不会违反种植规则。
- 输入的数组长度范围为 [1, 20000]。
- **n** 是非负整数，且不会超过输入数组的大小。

**题解**

**Java**

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        for(int i=0; i<flowerbed.length; i++){
            if(flowerbed[i] == 0 
                && (i == 0 || flowerbed[i-1] == 0)
                && (i == flowerbed.length-1 || flowerbed[i+1] == 0)){
                flowerbed[i] = 1;
                n--;
            }
        }
        return n <= 0;
    }
}
```

## 5.[[860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)]

**描述**

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。

顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

**示例**

**示例 1：**

```
输入：[5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
```

**示例 2：**

```
输入：[5,5,10]
输出：true
```

**示例 3：**

```
输入：[10,10]
输出：false
```

**提示：**

- `0 <= bills.length <= 10000`
- `bills[i]` 不是 `5` 就是 `10` 或是 `20` 

**题解**

**Java**

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int y5 = 0;
        int y10 = 0;
        int money = 0;
        for(int bill : bills){
            if(bill == 5){
                y5++;
                money += 5;
            }else if(bill == 10){
                y5--;
                if(y5 < 0) return false;
                y10++;
                money += 10;
            }else{
                if(y10 > 0){
                    y10--;
                    y5--;
                }else{
                    y5 -= 3;
                }
                if(y5 < 0) return false;
                money -= 15;
            }
        }
        return true;
    }
}
```

## 6.[[874. 模拟行走机器人](https://leetcode-cn.com/problems/walking-robot-simulation/)]

**描述**

机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：

-2：向左转 90 度
-1：向右转 90 度
1 <= x <= 9：向前移动 x 个单位长度
在网格上有一些格子被视为障碍物。

第 i 个障碍物位于网格点  (obstacles[i][0], obstacles[i][1])

机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。

返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。

**示例**

**示例 1：**

```
输入: commands = [4,-1,3], obstacles = []
输出: 25
解释: 机器人将会到达 (3, 4)
```

**示例 2：**

```
输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
输出: 65
解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处
```

**提示：**

- 0 <= commands.length <= 10000
- 0 <= obstacles.length <= 10000
- -30000 <= obstacle[i][0] <= 30000
- -30000 <= obstacle[i][1] <= 30000
- 答案保证小于 2 ^ 31

**题解**

**Java**

```java
class Solution {
    public int robotSim(int[] commands, int[][] obstacles) {
        // 最大值
        int max = 0;
        // 坐标
        int posX = 0, posY = 0;
        // 北0, 西3, 南2, 东1
        int direction = 0;
     	// 存储障碍物坐标
        Set<String> set = new HashSet<>();
        for(int[] obstacle : obstacles){
            int x = obstacle[0];
            int y = obstacle[1];
            set.add(new StringBuilder().append(x).append(",").append(y).toString());
        }
        // 遍历指令
        for(int command : commands){
            // 调整方向
            if(command == -2){
                direction = (direction + 3) % 4;
            }else if(command == -1){
                direction = (direction + 5) % 4;
            }
            // 移动坐标
            if(direction == 0){
                for(int i=0; i<command; i++){
                    posY++;
                    // 判断该坐标有没有障碍物
                    if(set.contains(new StringBuilder().append(posX).append(",").append(posY).toString())){
                        posY--;
                        break;
                    }
                }
            }else if(direction == 3){
                for(int i=0; i<command; i++){
                    posX--;
                    // 判断该坐标有没有障碍物
                    if(set.contains(new StringBuilder().append(posX).append(",").append(posY).toString())){
                        posX++;
                        break;
                    }
                }
            }else if(direction == 2){
                for(int i=0; i<command; i++){
                    posY--;
                    // 判断该坐标有没有障碍物
                    if(set.contains(new StringBuilder().append(posX).append(",").append(posY).toString())){
                        posY++;
                        break;
                    }
                }
            }else{
                for(int i=0; i<command; i++){
                    posX++;
                    // 判断该坐标有没有障碍物
                    if(set.contains(new StringBuilder().append(posX).append(",").append(posY).toString())){
                        posX--;
                        break;
                    }
                }
            }
            int x = Math.abs(posX);
            int y = Math.abs(posY);
            max = Math.max(max, x * x + y * y);
        }
        return max;
    }
}
```

