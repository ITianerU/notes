**题目来源**

[力扣（LeetCode）](https://leetcode-cn.com/)

[TOC]



# 排序-简单(1-20)

## 1.[[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)]

**描述**

给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。

**示例**

**示例 1：**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2：**

```
输入: s = "rat", t = "car"
输出: false
```

**说明:**

- 你可以假设字符串只包含小写字母。

**题解**

**Java**

```java
class Solution {
    // 桶排序
    public boolean isAnagram(String s, String t) {
        if(s.length() != t.length()) return false;
        int[] bucket = new int[26];
        for(char c : s.toCharArray()){
            bucket[c - 'a']++;
        }
        for(char c : t.toCharArray()){
            if(bucket[c - 'a'] == 0){
                return false;
            }
            bucket[c - 'a']--;
        }
        return true;
    }
}
```

## 2.[[252.会议室](https://leetcode-cn.com/problems/meeting-rooms)]

## 3.[[349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)]

**描述**

给定两个数组，编写一个函数来计算它们的交集。

**示例**

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

**示例 2：**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
```

**说明:**

- 输出结果中的每个元素一定是唯一的。
- 我们可以不考虑输出结果的顺序。

**题解**

**Java**

**方法1**

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if(nums1.length == 0 || nums2.length == 0) return new int[0];
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int[] ans = new int[Math.max(nums1.length, nums2.length)];
        int j=0;
        int start = 0;
        for(int i=0; i<nums1.length; i++){
            // nums1的当前值, 大于nums2的最大值, 结束遍历
            if(nums1[i] > nums2[nums2.length-1]) break;
            // nums1的当前值, 等于上一个值, 跳过
            if(i != 0 && nums1[i] == nums1[i-1]) continue;
            while(j<nums2.length){
                // 比较是否相同, 相同加到数组中
                if(nums1[i] == nums2[j]){
                    ans[start++] = nums1[i];
                    break;
                // 当nums1[i]的值, 比nums[j]的值小, 说明j再加, 也不会找到和nums[i]相同的值, 结束循环
                }else if(nums1[i] < nums2[j]){
                    break;
                }
                j++;
            }
        }
        return Arrays.copyOf(ans, start);
    }
}
```

**方法2**

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        int len1 = nums1.length, len2 = nums2.length;
        if(len1 == 0 || len2 == 0) return new int[0]; 
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int[] ans = new int[len1 > len2 ? len1 : len2];
        int index = 0, index1 = 0, index2 = 0;
        while(index1 < len1 && index2 < len2){
            // 相同添加进数组
            if(nums1[index1] == nums2[index2]){
                // 保证加入的不重复
                if(index1 == 0 || nums1[index1] != nums1[index1-1]){
                    ans[index++] = nums1[index1];
                }
                index1++;
                index2++;
            }else if(nums1[index1] < nums2[index2]){
                index1++;
            }else{
                index2++;
            }
        }
        return Arrays.copyOf(ans, index);
    }
}
```

## 4.[[350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)]

**描述**

给定两个数组，编写一个函数来计算它们的交集。

**示例**

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

**示例 2：**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

**说明：**

- 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
- 我们可以不考虑输出结果的顺序。

**题解**

**Java**

```java
class Solution {
    // 和上一题一模一样, 去掉了去重的代码
    public int[] intersect(int[] nums1, int[] nums2) {
        int len1 = nums1.length, len2 = nums2.length;
        if(len1 == 0 || len2 == 0) return new int[0];
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int[] ans = new int[len1 > len2 ? len1 : len2];
        int index = 0, index1 = 0, index2 = 0;
        while(index1 < len1 && index2 < len2){
            if(nums1[index1] == nums2[index2]){
                ans[index++] = nums1[index1];
                index1++;
                index2++;
            }else if(nums1[index1] < nums2[index2]){
                index1++;
            }else{
                index2++;
            }
        }
        return Arrays.copyOf(ans, index);
    }
}
```

## 5.[[922. 按奇偶排序数组 II](https://leetcode-cn.com/problems/sort-array-by-parity-ii/)]

**描述**

给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。

对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。

你可以返回任何满足上述条件的数组作为答案。

**示例**

**示例 1：**

```
输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
```

**说明：**

- `2 <= A.length <= 20000`
- `A.length % 2 == 0`
- `0 <= A[i] <= 1000`

**题解**

**Java**

```java
class Solution {
    public int[] sortArrayByParityII(int[] A) {
        int[] ans = new int[A.length];
        int evenIndex = 0;
        int oddIndex = 1;
        for(int num : A){
            if(num % 2 == 0){
                ans[evenIndex] = num;
                evenIndex += 2;
            }else{
                ans[oddIndex] = num;
                oddIndex += 2;
            }
        }
        return ans;
    }
}
```

## 6.[[976. 三角形的最大周长](https://leetcode-cn.com/problems/largest-perimeter-triangle/)]

**描述**

给定由一些正数（代表长度）组成的数组 `A`，返回由其中三个长度组成的、**面积不为零**的三角形的最大周长。

如果不能形成任何面积不为零的三角形，返回 `0`。

**示例**

**示例 1：**

```
输入：[2,1,2]
输出：5
```

**示例 2：**

```
输入：[1,2,1]
输出：0
```

**示例 3：**

```
输入：[3,2,3,4]
输出：10
```

**说明：**

- `3 <= A.length <= 10000`
- `1 <= A[i] <= 10^6`

**题解**

**Java**

```java
class Solution {
    public int largestPerimeter(int[] A) {
        int first = getMax(A);
        int second = getMax(A);
        int third = getMax(A);
        for(int i=0; i<A.length-2; i++){
            // 两个较小的边相加 > 第三条边 是三角形
            if(second + third > first){
                return second + third + first;
            }else{
                first = second;
                second = third;
                third = getMax(A);
            }
        }
        return 0;
    }
    // 每次找出当前数组的最大值返回, 并将该值, 置位-1;
    public int getMax(int[] A){
        int max = 0;
        int index = 0;
        for(int i = 0; i<A.length; i++){
            if(A[i] > max){
                max = A[i];
                index = i;
            }
        }
        A[index] = -1;
        return max;
    }
}
```

## 7.[[1030. 距离顺序排列矩阵单元格](https://leetcode-cn.com/problems/matrix-cells-in-distance-order/)]

**描述**

给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 <= r < R 且 0 <= c < C。

另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。

返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。）

**示例**

**示例 1：**

```
输入：R = 1, C = 2, r0 = 0, c0 = 0
输出：[[0,0],[0,1]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1]
```

**示例 2：**

```
输入：R = 2, C = 2, r0 = 0, c0 = 1
输出：[[0,1],[0,0],[1,1],[1,0]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]
[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。
```

**示例 3：**

```
输入：R = 2, C = 3, r0 = 1, c0 = 2
输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]
其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。
```

**说明：**

- `1 <= R <= 100`
- `1 <= C <= 100`
- `0 <= r0 < R`
- `0 <= c0 < C`

**题解**

**Java**

```java
class Solution {
    // 桶排序
    public int[][] allCellsDistOrder(int R, int C, int r0, int c0) {
        // 计算桶的最大数量
        int maxCount = Math.max(r0, R - 1 - r0) + Math.max(c0, C - 1 - c0);
        // 创建List桶, 桶存List, 桶内list存坐标 
        List<List<int[]>> bucket = new ArrayList();
        // 给桶初始化
        for(int i=0; i<=maxCount; i++){
            bucket.add(new ArrayList());
        }
        // 往桶内存值
        for(int i=0; i<R; i++){
            for(int j=0; j<C; j++){
                // 算出当前坐标和目标坐标的曼哈顿距离
                int res = Math.abs(i - r0) + Math.abs(j - c0);
                // 得到对应的桶, 往桶内存坐标
                bucket.get(res).add(new int[]{i,j});
            }
        }
        // 结果数组
        int[][] ans = new int[R*C][];
        int start = 0;
        // 遍历桶
        for(int i=0; i<=maxCount; i++){
            // 遍历桶内坐标数据, 填充到结果数组
            for(int[] tmp : bucket.get(i)){
                ans[start++] = tmp;
            }
        }
        return ans;
    }
}
```

## 8.[[1086.前五科的均分](https://leetcode-cn.com/problems/high-five)]

## 9.[[1099.小于 K 的两数之和](https://leetcode-cn.com/problems/two-sum-less-than-k)]

## 10.[[1122. 数组的相对排序](https://leetcode-cn.com/problems/relative-sort-array/)]

**描述**

给你两个数组，arr1 和 arr2，

- arr2 中的元素各不相同
- arr2 中的每个元素都出现在 arr1 中

对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。

**示例**

**示例 1：**

```
输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出：[2,2,2,1,4,3,3,9,6,7,19]
```

**说明：**

- 1 <= arr1.length, arr2.length <= 1000
- 0 <= arr1[i], arr2[i] <= 1000
- arr2 中的元素 arr2[i] 各不相同
- arr2 中的每个元素 arr2[i] 都出现在 arr1 中

**题解**

**Java**

```java
class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        int[] ans = new int[arr1.length];
        int[] bucket = new int[1001];
        for(int num : arr1){
            bucket[num]++;
        }
        int start = 0;
        for(int num : arr2){
            while(bucket[num] != 0){
                ans[start++] = num;
                bucket[num]--;
            }
        }
        for(int i=0; i < bucket.length; i++){
            while(bucket[i] != 0){
                ans[start++] = i;
                bucket[i]--;
            }
        }
        return ans;
        
    }
}
```

