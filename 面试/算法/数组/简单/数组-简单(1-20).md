**题目来源**

[力扣（LeetCode）](https://leetcode-cn.com/)

[TOC]



# 数组-简单(1-20)

## 1.[[27. 移除元素](https://leetcode-cn.com/problems/remove-element/)]

**描述**

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**示例**

**示例 1：**

```
给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
```

**示例 2:**

```
给定 nums = [0,1,2,2,3,0,4,2], val = 2,
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。
你不需要考虑数组中超出新长度后面的元素。
```

**题解**

**Java**

```java
class Solution {
    public int removeElement(int[] nums, int val) {
       int slow = 0;
       for(int fast=0; fast<nums.length; fast++){
           if(nums[fast] != val){
               nums[slow] = nums[fast];
               slow++;
           }
       }
       return slow;
    }
}
```

## 2.[[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)]

**描述**

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例**

**示例 1：**

```
输入: [1,3,5,6], 5
输出: 2
```

**示例 2：**

```
输入: [1,3,5,6], 2
输出: 1
```

**示例 3:**

```
输入: [1,3,5,6], 7
输出: 4
```

**示例 4:**

```
输入: [1,3,5,6], 0
输出: 0
```

**题解**

**Java**

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while(left <= right) {
            int mid = (left + right) / 2;
            if(nums[mid] == target) {
                return mid;
            } else if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
}
```

## 2.[[118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)]

**描述**

给定一个非负整数 *numRows，*生成杨辉三角的前 *numRows* 行。

**示例**

**示例 1：**

```
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

**题解**

**Java**

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> result = new ArrayList<>();
        for(int i=0; i<numRows; i++){
            List<Integer> list = new ArrayList<>();
            for(int j=0; j<=i; j++){
                if(j == 0 || j == i){
                    list.add(1);
                }else{
                    list.add(result.get(i-1).get(j-1) + result.get(i-1).get(j));
                }
            }
            result.add(list);
        }
        return result;
    }
}
```

## 2.[[119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)]

**描述**

给定一个非负索引 *k*，其中 *k* ≤ 33，返回杨辉三角的第 *k* 行。

**示例**

**示例 1：**

```
输入: 3
输出: [1,3,3,1]
```

**题解**

**Java**

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> list = new ArrayList<>();
        for(int i = 0; i <= rowIndex; i++){
            for(int j = 0; j <= i; j++){
                if(j == 0){
                    list.add(1);
                }else if(j == i){
                    continue;
                }else{
                    list.set(i-j, list.get(i-j-1) + list.get(i-j));
                }
            }
        }
        return list;
    }
}
```

## 3.[[167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)]

**描述**

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

**说明:**

- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例**

**示例 1：**

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**题解**

**Java**

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        int[] result = new int[2];
        while(left < right){
            int sum = numbers[left] + numbers[right];
            if(sum == target){
                result[0] = left+1;
                result[1] = right+1;
                return result;
            }else if(sum < target){
                left++;
            }else{
                right--;
            }
        }
        return result;
    }
}
```

## 4.[[485. 最大连续1的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)]

**描述**

给定一个二进制数组， 计算其中最大连续1的个数。

**示例**

**示例 1：**

```
输入: [1,1,0,1,1,1]
输出: 3
解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.
```

**注意：**

- 输入的数组只包含 `0` 和`1`。
- 输入数组的长度是正整数，且不超过 10,000。

**题解**

**Java**

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int max = 0;
        int tmp = 0;
        for(int num : nums){
            if(num == 1){
                tmp++;
            }else{
                max = Math.max(max, tmp);
                tmp = 0;
            }
        }
        return Math.max(max, tmp);
    }
}
```

## 5.[[724. 寻找数组的中心索引](https://leetcode-cn.com/problems/find-pivot-index/)]

**描述**

给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。

我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。

如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。

**示例**

**示例 1：**

```
输入：
nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。
同时, 3 也是第一个符合要求的中心索引。
```

**示例 2：**

```
输入：
nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心索引。
```

**题解**

**Java**

```java
class Solution {
    public int pivotIndex(int[] nums) {
        // 先计算出数组的和
        int allSum = sum(nums, 0, nums.length);
        int leftSum = 0;
        for(int i=0;i<nums.length; i++){
            // 公式, 数组和 - 中心索引的值 - 中心索引左边的值 = 中心索引右边的值
            if(allSum - leftSum - nums[i] == leftSum){
                return i;
            }else{
                leftSum += nums[i];
            }
        }
        return -1;
    }

    public int sum(int[] nums, int start, int end){
        int sum = 0;
        while(start < end){
            sum += nums[start];
            start++;
        }
        return sum;
    }
}
```

