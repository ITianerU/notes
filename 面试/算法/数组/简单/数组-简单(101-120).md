题目来源**

[力扣（LeetCode）](https://leetcode-cn.com/)

[TOC]



# 数组-简单(101-120)

## 101.[[1475. 商品折扣后的最终价格](https://leetcode-cn.com/problems/final-prices-with-a-special-discount-in-a-shop/)]

**描述**

给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。

商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j > i 且 prices[j] <= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。

请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。

**示例**

**示例 1：**

```
输入：prices = [8,4,6,2,3]
输出：[4,2,4,2,3]
解释：
商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。
商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。
商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。
商品 3 和 4 都没有折扣。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：[1,2,3,4,5]
解释：在这个例子中，所有商品都没有折扣。
```

**示例 3：**

```
输入：prices = [10,1,1,6]
输出：[9,0,1,6]
```

**提示：**

- `1 <= prices.length <= 500`
- `1 <= prices[i] <= 10^3`

**题解**

**Java**

```java
class Solution {
    public int[] finalPrices(int[] prices) {
        int[] ans = new int[prices.length];
        for(int i=0; i<prices.length; i++){
            boolean is = true;
            for(int j=i+1; j<prices.length; j++){
                if(prices[j] <= prices[i]){
                    ans[i] = prices[i] - prices[j];
                    is = false;
                    break;
                }
            }
            if(is){
                ans[i] = prices[i];
            }
        }
        return ans;
    }
}
```

## 102.[[1480. 一维数组的动态和](https://leetcode-cn.com/problems/running-sum-of-1d-array/)]

**描述**

给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。

请返回 nums 的动态和。

**示例**

**示例 1：**

```
输入：nums = [1,2,3,4]
输出：[1,3,6,10]
解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。
```

**示例 2：**

```
输入：nums = [1,1,1,1,1]
输出：[1,2,3,4,5]
解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。
```

**示例 3：**

```
输入：nums = [3,1,2,10,1]
输出：[3,4,6,16,17]
```

**提示：**

- `1 <= nums.length <= 1000`
- `-10^6 <= nums[i] <= 10^6`

**题解**

**Java**

```java
class Solution {
    public int[] runningSum(int[] nums) {
        int[] ans = new int[nums.length];
        ans[0] = nums[0];
        for(int i=1; i<nums.length; i++){
            ans[i] = ans[i-1] + nums[i];
        }
        return ans;
    }
}
```

## 103.[[1486. 数组异或操作](https://leetcode-cn.com/problems/xor-operation-in-an-array/)]

**描述**

给你两个整数，n 和 start 。

数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。

请返回 nums 中所有元素按位异或（XOR）后得到的结果。

**示例**

**示例 1：**

```
输入：n = 5, start = 0
输出：8
解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。
     "^" 为按位异或 XOR 运算符。
```

**示例 2：**

```
输入：n = 4, start = 3
输出：8
解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.
```

**示例 3：**

```
输入：n = 1, start = 7
输出：7
```

**提示：**

- `1 <= n <= 1000`
- `0 <= start <= 1000`
- `n == nums.length`

**题解**

**Java**

```java
class Solution {
    public int xorOperation(int n, int start) {
        int ans = 0;
        for(int i=0; i<n; i++){
            ans ^= start + 2 * i;
        }
        return ans;
    }
}
```

## 104.[[1491. 去掉最低工资和最高工资后的工资平均值](https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/)]

**描述**

给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。

请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。

**示例**

**示例 1：**

```
输入：salary = [4000,3000,1000,2000]
输出：2500.00000
解释：最低工资和最高工资分别是 1000 和 4000 。
去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500
```

**示例 2：**

```
输入：salary = [1000,2000,3000]
输出：2000.00000
解释：最低工资和最高工资分别是 1000 和 3000 。
去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000
```

**示例 3：**

```
输入：salary = [6000,5000,4000,3000,2000,1000]
输出：3500.00000
```

**提示：**

- 3 <= salary.length <= 100
- 10^3 <= salary[i] <= 10^6
- salary[i] 是唯一的。
- 与真实值误差在 10^-5 以内的结果都将视为正确答案。

**题解**

**Java**

```java
class Solution {
    public double average(int[] salary) {
        double sum = 0;
        double min = Double.MAX_VALUE;
        double max = Double.MIN_VALUE;
        for(int s : salary){
            if(min > s){
                min = s;
            }
            if(max < s){
                max = s;
            }
            sum += s;
        }
        return (sum - min - max) / (salary.length - 2);
    }
}
```

## 105.[[1502. 判断能否形成等差数列](https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence/)]

**描述**

给你一个数字数组 arr 。

如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。

如果可以重新排列数组形成等差数列，请返回 true ；否则，返回 false 。

**示例**

**示例 1：**

```
输入：arr = [3,5,1]
输出：true
解释：对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。
```

**示例 2：**

```
输入：arr = [1,2,4]
输出：false
解释：无法通过重新排序得到等差数列。
```

**提示：**

- `2 <= arr.length <= 1000`
- `-10^6 <= arr[i] <= 10^6`

**题解**

**Java**

```java
class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int d = arr[1] - arr[0];
        for(int i=2; i<arr.length; i++){
            if(arr[i] - arr[i-1] != d){
                return false;
            }
        }
        return true;
    }
}
```

## 106.[[1512. 好数对的数目](https://leetcode-cn.com/problems/number-of-good-pairs/)]

**描述**

给你一个整数数组 nums 。

如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i < j ，就可以认为这是一组 好数对 。

返回好数对的数目。

**示例**

**示例 1：**

```
输入：nums = [1,2,3,1,1,3]
输出：4
解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始
```

**示例 2：**

```
输入：nums = [1,1,1,1]
输出：6
解释：数组中的每组数字都是好数对
```

**示例 3：**

```
输入：nums = [1,2,3]
输出：0
```

**提示：**

- `1 <= nums.length <= 100`
- `1 <= nums[i] <= 100`

**题解**

**Java**

```java
class Solution {
    // 桶排序
    public int numIdenticalPairs(int[] nums) {
        int[] bucket = new int[101];
        for(int num : nums){
            bucket[num]++;
        }
        int count = 0;
        for(int num : bucket){
            if(num > 1){
                count += num * (num - 1) / 2;
            }
        }
        return count;
    }
}
```

## 107.[[1534. 统计好三元组](https://leetcode-cn.com/problems/count-good-triplets/)]

**描述**

给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量。

如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 。

- 0 <= i < j < k < arr.length
- |arr[i] - arr[j]| <= a
- |arr[j] - arr[k]| <= b
- |arr[i] - arr[k]| <= c

其中 |x| 表示 x 的绝对值。

返回 好三元组的数量 。

**示例**

**示例 1：**

```
输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
输出：4
解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。
```

**示例 2：**

```
输入：arr = [1,1,2,2,3], a = 0, b = 0, c = 1
输出：0
解释：不存在满足所有条件的三元组。
```

**提示：**

- `3 <= arr.length <= 100`
- `0 <= arr[i] <= 1000`
- `0 <= a, b, c <= 1000`

**题解**

**Java**

```java
class Solution {
    // 暴力解法
    public int countGoodTriplets(int[] arr, int a, int b, int c) {
        int count = 0;
        for(int i=0; i<arr.length; i++){
            for(int j=i+1; j<arr.length; j++){
                for(int k=j+1; k<arr.length; k++){
                    if(Math.abs(arr[i] - arr[j]) <= a 
                        && Math.abs(arr[j] - arr[k]) <= b
                            && Math.abs(arr[i] - arr[k]) <= c){
                        count++;
                    }
                }
            }
        }
        return count;
    }
}
```

## 108.[[1539. 第 k 个缺失的正整数](https://leetcode-cn.com/problems/kth-missing-positive-number/)]

**描述**

给你一个 **严格升序排列** 的正整数数组 `arr` 和一个整数 `k` 。

请你找到这个数组里第 `k` 个缺失的正整数。

**示例**

**示例 1：**

```
输入：arr = [2,3,4,7,11], k = 5
输出：9
解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。
```

**示例 2：**

```
输入：arr = [1,2,3,4], k = 2
输出：6
解释：缺失的正整数包括 [5,6,7,...] 。第 2 个缺失的正整数为 6 。
```

**提示：**

- 1 <= arr.length <= 1000
- 1 <= arr[i] <= 1000
- 1 <= k <= 1000
- 对于所有 1 <= i < j <= arr.length 的 i 和 j 满足 arr[i] < arr[j] 

**题解**

**Java**

```java
class Solution {
    // 根据下标与当前值的差, 判断缺了多少数字
    public int findKthPositive(int[] arr, int k) {
        for(int i=0; i<arr.length; i++){
            if(arr[i] - (i + 1) >= k){
                return i+k;
            }
        }
        return arr.length + k;
    }
}
```

## 109.[[1550. 存在连续三个奇数的数组](https://leetcode-cn.com/problems/three-consecutive-odds/)]

**描述**

给你一个整数数组 `arr`，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 `true` ；否则，返回 `false` 。

**示例**

**示例 1：**

```
输入：arr = [2,6,4,1]
输出：false
解释：不存在连续三个元素都是奇数的情况。
```

**示例 2：**

```
输入：arr = [1,2,34,3,4,5,7,23,12]
输出：true
解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。
```

**提示：**

- `1 <= arr.length <= 1000`
- `1 <= arr[i] <= 1000`

**题解**

**Java**

```java
class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for(int i=0, j=1, k=2; k<arr.length; i++, j++, k++){
            if(arr[i] % 2 == 1 && arr[j] % 2 == 1 && arr[k] % 2 == 1){
                return true;
            }
        }
        return false;
    }
}
```

## 110.[[1560. 圆形赛道上经过次数最多的扇区](https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track/)]

**描述**

给你一个整数 n 和一个整数数组 rounds 。有一条圆形赛道由 n 个扇区组成，扇区编号从 1 到 n 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 m 个阶段组成。其中，第 i 个阶段将会从扇区 rounds[i - 1] 开始，到扇区 rounds[i] 结束。举例来说，第 1 阶段从 rounds[0] 开始，到 rounds[1] 结束。

请你以数组形式返回经过次数最多的那几个扇区，按扇区编号 升序 排列。

注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。

**示例**

**示例 1：**

```
输入：n = 4, rounds = [1,3,1,2]
输出：[1,2]
解释：本场马拉松比赛从扇区 1 开始。经过各个扇区的次序如下所示：
1 --> 2 --> 3（阶段 1 结束）--> 4 --> 1（阶段 2 结束）--> 2（阶段 3 结束，即本场马拉松结束）
其中，扇区 1 和 2 都经过了两次，它们是经过次数最多的两个扇区。扇区 3 和 4 都只经过了一次。
```

**示例 2：**

```
输入：n = 2, rounds = [2,1,2,1,2,1,2,1,2]
输出：[2]
```

**示例 3:**

```
输入：n = 7, rounds = [1,3,5,7]
输出：[1,2,3,4,5,6,7]
```

**提示：**

- `1 <= arr.length <= 1000`
- `1 <= arr[i] <= 1000`

**题解**

**Java**

```java
class Solution {
    // 因为是圆形跑道, 只需考虑起点和终点
    public List<Integer> mostVisited(int n, int[] rounds) {
        List<Integer> ans = new ArrayList<>();
        int start = rounds[0], end = rounds[rounds.length - 1];
        if(start <= end){
            for(int i=start; i<=end; i++){
                ans.add(i);
            }
        }else{
            for(int i=1; i<=end; i++){
                ans.add(i);
            }
            for(int i=start; i<=n; i++){
                ans.add(i);
            }
        }
        return ans;
    }
}
```

## 111.[[1566. 重复至少 K 次且长度为 M 的模式](https://leetcode-cn.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/)]

**描述**

给你一个正整数数组 arr，请你找出一个长度为 m 且在数组中至少重复 k 次的模式。

模式 是由一个或多个值组成的子数组（连续的子序列），连续 重复多次但 不重叠 。 模式由其长度和重复次数定义。

如果数组中存在至少重复 k 次且长度为 m 的模式，则返回 true ，否则返回  false 。

**示例**

**示例 1：**

```
输入：arr = [1,2,4,4,4,4], m = 1, k = 3
输出：true
解释：模式 (4) 的长度为 1 ，且连续重复 4 次。注意，模式可以重复 k 次或更多次，但不能少于 k 次。
```

**示例 2：**

```
输入：arr = [1,2,1,2,1,1,1,3], m = 2, k = 2
输出：true
解释：模式 (1,2) 长度为 2 ，且连续重复 2 次。另一个符合题意的模式是 (2,1) ，同样重复 2 次。
```

**示例 3:**

```
输入：arr = [1,2,1,2,1,3], m = 2, k = 3
输出：false
解释：模式 (1,2) 长度为 2 ，但是只连续重复 2 次。不存在长度为 2 且至少重复 3 次的模式。
```

**提示：**

- `2 <= arr.length <= 100`
- `1 <= arr[i] <= 100`
- `1 <= m <= 100`
- `2 <= k <= 100`

**题解**

**Java**

```java
class Solution {
    public boolean containsPattern(int[] arr, int m, int k) {
        // 连续子数组的长度是 m*k, 所以只需要遍历 arr.length - m*k次
        for(int i=0; i<=arr.length-m*k; i++){
            int j = 0;
            // 比较每一小段是否相同, 不相同就结束遍历
            for(; j<m*k; j++){
                if(arr[i + j] != arr[i + j % m]){
                    break;
                }
            }
            // 如果能遍历完, 则说明满足k个子数组
            if(j == m*k){
                return true;
            }
        }
        return false;
    }
}
```

