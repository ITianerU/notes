题目来源**

[力扣（LeetCode）](https://leetcode-cn.com/)

[TOC]



# 数组-简单(101-120)

## 101.[[1475. 商品折扣后的最终价格](https://leetcode-cn.com/problems/final-prices-with-a-special-discount-in-a-shop/)]

**描述**

给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。

商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j > i 且 prices[j] <= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。

请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。

**示例**

**示例 1：**

```
输入：prices = [8,4,6,2,3]
输出：[4,2,4,2,3]
解释：
商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。
商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。
商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。
商品 3 和 4 都没有折扣。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：[1,2,3,4,5]
解释：在这个例子中，所有商品都没有折扣。
```

**示例 3：**

```
输入：prices = [10,1,1,6]
输出：[9,0,1,6]
```

**提示：**

- `1 <= prices.length <= 500`
- `1 <= prices[i] <= 10^3`

**题解**

**Java**

```java
class Solution {
    public int[] finalPrices(int[] prices) {
        int[] ans = new int[prices.length];
        for(int i=0; i<prices.length; i++){
            boolean is = true;
            for(int j=i+1; j<prices.length; j++){
                if(prices[j] <= prices[i]){
                    ans[i] = prices[i] - prices[j];
                    is = false;
                    break;
                }
            }
            if(is){
                ans[i] = prices[i];
            }
        }
        return ans;
    }
}
```

## 102.[[1480. 一维数组的动态和](https://leetcode-cn.com/problems/running-sum-of-1d-array/)]

**描述**

给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。

请返回 nums 的动态和。

**示例**

**示例 1：**

```
输入：nums = [1,2,3,4]
输出：[1,3,6,10]
解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。
```

**示例 2：**

```
输入：nums = [1,1,1,1,1]
输出：[1,2,3,4,5]
解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。
```

**示例 3：**

```
输入：nums = [3,1,2,10,1]
输出：[3,4,6,16,17]
```

**提示：**

- `1 <= nums.length <= 1000`
- `-10^6 <= nums[i] <= 10^6`

**题解**

**Java**

```java
class Solution {
    public int[] runningSum(int[] nums) {
        int[] ans = new int[nums.length];
        ans[0] = nums[0];
        for(int i=1; i<nums.length; i++){
            ans[i] = ans[i-1] + nums[i];
        }
        return ans;
    }
}
```

## 103.[[1486. 数组异或操作](https://leetcode-cn.com/problems/xor-operation-in-an-array/)]

**描述**

给你两个整数，n 和 start 。

数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。

请返回 nums 中所有元素按位异或（XOR）后得到的结果。

**示例**

**示例 1：**

```
输入：n = 5, start = 0
输出：8
解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。
     "^" 为按位异或 XOR 运算符。
```

**示例 2：**

```
输入：n = 4, start = 3
输出：8
解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.
```

**示例 3：**

```
输入：n = 1, start = 7
输出：7
```

**提示：**

- `1 <= n <= 1000`
- `0 <= start <= 1000`
- `n == nums.length`

**题解**

**Java**

```java
class Solution {
    public int xorOperation(int n, int start) {
        int ans = 0;
        for(int i=0; i<n; i++){
            ans ^= start + 2 * i;
        }
        return ans;
    }
}
```

## 104.[[1491. 去掉最低工资和最高工资后的工资平均值](https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/)]

**描述**

给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。

请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。

**示例**

**示例 1：**

```
输入：salary = [4000,3000,1000,2000]
输出：2500.00000
解释：最低工资和最高工资分别是 1000 和 4000 。
去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500
```

**示例 2：**

```
输入：salary = [1000,2000,3000]
输出：2000.00000
解释：最低工资和最高工资分别是 1000 和 3000 。
去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000
```

**示例 3：**

```
输入：salary = [6000,5000,4000,3000,2000,1000]
输出：3500.00000
```

**提示：**

- 3 <= salary.length <= 100
- 10^3 <= salary[i] <= 10^6
- salary[i] 是唯一的。
- 与真实值误差在 10^-5 以内的结果都将视为正确答案。

**题解**

**Java**

```java
class Solution {
    public double average(int[] salary) {
        double sum = 0;
        double min = Double.MAX_VALUE;
        double max = Double.MIN_VALUE;
        for(int s : salary){
            if(min > s){
                min = s;
            }
            if(max < s){
                max = s;
            }
            sum += s;
        }
        return (sum - min - max) / (salary.length - 2);
    }
}
```

## 105.[[1502. 判断能否形成等差数列](https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence/)]

**描述**

给你一个数字数组 arr 。

如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。

如果可以重新排列数组形成等差数列，请返回 true ；否则，返回 false 。

**示例**

**示例 1：**

```
输入：arr = [3,5,1]
输出：true
解释：对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。
```

**示例 2：**

```
输入：arr = [1,2,4]
输出：false
解释：无法通过重新排序得到等差数列。
```

**提示：**

- `2 <= arr.length <= 1000`
- `-10^6 <= arr[i] <= 10^6`

**题解**

**Java**

```java
class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int d = arr[1] - arr[0];
        for(int i=2; i<arr.length; i++){
            if(arr[i] - arr[i-1] != d){
                return false;
            }
        }
        return true;
    }
}
```

