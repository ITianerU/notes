# 创建型模式

## 工厂模式

### 接口

```java
// 接口
interface Phone{
    void brand();
}
```

### 接口实现类

```java
// 接口不同的实现类
class Huawei implements Phone{
    @Override
    public void brand() {
        System.out.println("one huawei");
    }
}
class Iphone implements Phone{
    @Override
    public void brand() {
        System.out.println("one iphone");
    }
}
```

### 工厂

```java
// 工厂通过不同的参数, 创建不同的实现类
class PhoneFactory{
    public static Phone createPhone(String name){
        if(name.equals("华为")){
            return new Huawei();
        }else if(name.equals("苹果")){
            return new Iphone();
        }
        return null;
    }
}
```

### 测试

```java
public class Main {
    public static void main(String[] args) {
        PhoneFactory.createPhone("华为").brand();
        PhoneFactory.createPhone("苹果").brand();
    }
}
```

## 抽线工厂模式

### 接口

```java
interface Computer{
    String internet();
}
interface Phone{
    String call();
}
```

### 实现类

```java
class PhoneApple implements Phone{
    @Override
    public String call() {
        return "iphone手机";
    }
}

class PhoneHuaWei implements Phone{
    @Override
    public String call() {
        return "huawei手机";
    }
}
```

```java
class ComputerApple implements Computer{
    @Override
    public String internet() {
        return "iphone电脑";
    }
}

class ComputerHuaWei implements Computer{
    @Override
    public String internet() {
        return "huawei电脑";
    }
}
```

### 抽象工厂

```java
public abstract class AbstractFactory {
    public abstract Phone createPhone(String brand);
    public abstract Computer createComputer(String brand);
}
```

### 实现工厂

```java
class PhoneFactory extends AbstractFactory{
    @Override
    public Phone createPhone(String brand) {
        if(brand.equals("华为")){
            return new PhoneHuaWei();
        }else if(brand.equals("苹果")){
            return new PhoneApple();
        }
        return null;
    }
    @Override
    public Computer createComputer(String brand) {
        return null;
    }
}
```

```java
class ComputerFactory extends AbstractFactory{
    @Override
    public Phone createPhone(String brand) {
        return null;
    }
    @Override
    public Computer createComputer(String brand) {
        if(brand.equals("华为")){
            return new ComputerHuaWei();
        }else if(brand.equals("苹果")){
            return new ComputerApple();
        }
        return null;
    }
}
```

### 测试

```java
public class Main {
    public static void main(String[] args) {
        AbstractFactory phoneFactory = new PhoneFactory();
        Phone phoneHuawei = phoneFactory.createPhone("华为");
        Phone phoneApple = phoneFactory.createPhone("苹果");
        System.out.println(phoneHuawei.call());
        System.out.println(phoneApple.call());
        AbstractFactory computerFactory = new ComputerFactory();
        Computer computerHuawei = computerFactory.createComputer("华为");
        Computer computerApple = computerFactory.createComputer("苹果");
        System.out.println(computerHuawei.internet());
        System.out.println(computerApple.internet());
    }
}
```

## 单例模式

### 懒汉式(不推荐)

懒汉式的意思是, 懒表示懒加载, 是指在使用的时候才开始实例化

因为加了synchronized同步锁, 所以是线程安全的, 但是因为每次加锁, 性能低, 不推荐使用

```java
public class LazySingleton {
    private static LazySingleton instance;
    public static synchronized LazySingleton getInstance() {
        if (instance != null){
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

### 饿汉式(不推荐)

饿汉式的意思是, 表示不等待系统去调用, 在class被加载时就实例化对象, 占用较多空间

因为是静态对象, 该对象不会被修改, 所以是线程安全的.

```java
public class HungrySingleton {
    private static HungrySingleton instance = new HungrySingleton();
    public static HungrySingleton getInstance() {
        return instance;
    }
}
```

### 静态内部类(推荐)

外部类被加载时, 内部类不会被加载, 所以要比饿汉式节省空间

在调用getInstance时, 内部类被加载, 初始化外部类静态实例, 由于是静态对象, 所以要比懒汉式线程安全

```java
public class Singleton{
	private static class SingletonHolder{
        private static final Singleton INSTANCE = new Singleton();
    }
    public static final Singleton getInstance(){
        return SingletonHolder.INSTANCE;
    }
}
```

### 双重校验锁(不推荐)

是对懒汉模式的优化, 第一次判断 INSTANCE == null为了避免非必要加锁，当第一次加载时才对实例进行加锁再实例化。
这样既可以节约内存空间，又可以保证线程安全。
**正常的步骤下**:

1. 分配一块内存M
2. 在M上创建Singleton对象
3. 将singleton的引用指向内存M

但是在CPU对于执行指令的优化下，有可能执行顺序是

1. 分配一块内存M
2. 将singleton的引用指向内存M
3. 在M上创建Singleton对象

如果CPU优化后，A线程刚执行完2.将singleton的引用指向内存M这一段代码，B线程执行到最外层的if(singleton == null)，这时候会直接认为singleton是不为空的，然后将这个并没有初始化完成的singleton实例返回，如果使用这个空的singleton对象，那么会触发NullPointer异常。所以这里给singleton变量增加volatile关键字，这样cpu就不会对指令进行重排序了。

```java
public class Lock2Singleton {
    private volatile static Lock2Singleton singleton;
    public static Lock2Singleton getInstance(){
        if (singleton == null){
            synchronized (Lock2Singleton.class){
                if (singleton == null){
                    singleton = new Lock2Singleton();
                }
            }
        }
        return singleton;
    }
}
```



# 结构型模式

# 行为型模式